<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebView资料]]></title>
    <url>%2F2019%2F02%2F26%2Fandroid-2019-02-26-WebView%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[Webview一、Webview常见的坑1.Android API level 16 以及之前的版本存在远程代码执行安全漏洞，该漏洞的源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java Relflection API 利用该漏洞执行任意Java对象的方法。2.webview 在布局文件中使用的时候，在界面销毁的时候先调用webView destroy() 方法,不然会造成内存泄漏。3.jsbridge 实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。 4.webviewClient.onPageFinished(不准确)-&gt;WebChromeClient.onProgressChanged 5、后台耗电的问题 6、硬件加速渲染界面，界面闪烁、白块等问题。 二、关于webview的内存泄漏的问题1、独立进程，简单暴力，不过涉及进程间通信2、动态添加WebView,对传入WebView中使用Context使用弱引用，动态添加WebView意思在布局中创建个ViewGroup用来放置WebView,Activity创建时add进来，在Activity remove调，然后再destory掉。]]></content>
      <categories>
        <category>Android</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android自定义控件使用系统的属性]]></title>
    <url>%2F2018%2F12%2F01%2Fandroid-2018-12-01-android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[android自定义控件使用系统的属性自定义一个EditText控件 12345678910&lt;declare-styleable name=&quot;CursorCompatEditText&quot;&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color|reference&quot;/&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt; &lt;/declare-styleable&gt; &lt;com.foton.android.widget.CursorCompatEditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:textColor=&quot;@color/colorPrimary&quot; app:textSize=&quot;@dimen/font_14&quot;/&gt; 如果想直接使用系统的inputType属性，自己一个一个定义是不应该的，可以使用下面的方法调用系统的属性 12345&lt;declare-styleable name=&quot;CursorCompatEditText&quot;&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color|reference&quot;/&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;android:inputType&quot;/&gt;&lt;/declare-styleable&gt; 123456&lt;com.foton.android.widget.CursorCompatEditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;number&quot; app:textColor=&quot;@color/colorPrimary&quot; app:textSize=&quot;@dimen/font_14&quot; /&gt; 在代码中获取属性设置到 EditText中 123TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.CursorCompatEditText);int inputType = a.getInt(R.styleable.CursorCompatEditText_android_inputType, EditorInfo.TYPE_NULL);a.recycle();]]></content>
      <categories>
        <category>Android</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图上计算两点的方向]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%9C%B0%E5%9B%BE%E4%B8%8A%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%82%B9%E7%9A%84%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425public double GetAngle(MapPoint pntFirst, MapPoint pntNext) &#123; double dRotateAngle = Math.Atan2(Math.Abs(pntFirst.X - pntNext.X), Math.Abs(pntFirst.Y - pntNext.Y)); if (pntNext.X &gt;= pntFirst.X) &#123; if (pntNext.Y &gt;= pntFirst.Y) &#123; &#125; else &#123; dRotateAngle = Math.PI - dRotateAngle; &#125; &#125; else&#123; if (pntNext.Y &gt;= pntFirst.Y) &#123; dRotateAngle = 2 * Math.PI - dRotateAngle; &#125; else&#123; dRotateAngle = Math.PI + dRotateAngle; &#125; &#125; dRotateAngle = dRotateAngle * 180 / Math.PI; return dRotateAngle; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H.264编码简介]]></title>
    <url>%2F2018%2F11%2F28%2FH-264%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[H.264 H.264编码简介 H.264原始码流（又称为“裸流”）是由一个一个的NALU组成的。他们的结构如下图所示。 视频编码层（VCL， Video Coding Layer） VCL输出的是原始数据比特流（SODB，String of data bits），表示H.264的语法元素编码完成后的实际的原始二进制码流。SODB通常不能保证字节对齐,故需要补齐为原始字节序列负荷（RBSP，Raw Byte Sequence Payload）。 网络提取层（NAL，Network Abstraction Layer） NAL层实际上就是最终输出的H.264码流，它是由一个个NALU组成的，每个NALU包括一组对应于视频编码数据的NAL头信息和一个原始字节序列负荷（RBSP，Raw Byte Sequence Payload）。 123RBSP = SODB + RBSP trailing bitsNALU = NAL header(1 byte) + RBSPH.264 = Start Code Prefix(3 bytes) + NALU + Start Code Prefix(3 bytes) + NALU +… H.264码流解构图如下： Start Code 每个NALU之间由起始码（Start Code Prefix）分隔，起始码分为两种：0x000001(3 bytes) or 0x00000001(4 bytes). 如果NALU 对应的Slice 为一帧的开始，则用4 字节表示，即0x00000001；否则用3 字节表示，0x000001.NALU针对起始码设计了防止冲突机制，如果出现连续的0x000000，0x000001,0x000002,0x000003时，会在两个0之间插入03，如下： 12340x00 00 00 -&gt; 0x00 00 03 000x00 00 01 -&gt; 0x00 00 03 010x00 00 02 -&gt; 0x00 00 03 020x00 00 03 -&gt; 0x00 00 03 03 NAL header 一个NALU就是编码后的一帧数据。NAL header是1byte NAL header头的格式 ： forbidden_bit(1bit) + nal_reference_bit(2bit) + nal_unit_type(5bit) forbidden_zero_bit(1 bit) 禁止位，如果有语法冲突，则为 1。当网络识别此单元存在比特错误时，可将其设为 1，以便接收方丢掉该单元。 nal_ref_idc(2 bit)指示当前NAL的优先级，取值范围为0~3，值越高，表示当前NAL越重要。H.264规定，如果当前NAL是序列参数集，或是图像参数等，该值必须大于0.比如nal_unit_type等于5时，nal_ref_idc大于0；nal_unit_type等于6,9,10,11或12时，nal_ref_idc等于0； nal_unit_type表示当前NALU的类型，表格如下： 表 nal_unit_type nal_unit_type NAL类型 C 0 未使用 1 未使用Data Partitioning、非IDR图像的Slice 2，3，4 2 使用Data Partitioning、且为Slice A 2 3 使用Data Partitioning、且为Slice B 3 4 使用Data Partitioning、且为Slice C 4 5 IDR图像中的Slice 2，3 6 补充增强信息单元（SEI） 5 7 序列参数集（Sequence Parameter Set,SPS） 0 8 图像参数集（Picture Parameter Set,PPS） 1 9 分界符 6 10 序列结束 7 11 码流结束 8 12 填充 9 13…23 保留 24…31 未使用 nal_unit_type=5时，表示当前NAL是IDR图像的一个片，此时，IDR图像中的每个片的nal_unit_type都应该等于5。 一般H.264原始码流是以SPS-&gt;PPS-&gt;SEI-&gt;IDR-&gt;SLICE-&gt;SLICE…开头的。 GOP即Group of picture(图像组)，指两个I帧之间的距离。即几秒有一个关键帧。一般在2、3秒之间。 图像示意图 H.264有两种封装模式： （1）annexb模式：传统模式，有start code， SPS和PPS是在ES中； （2）mp4模式：没有start code，SPS和PPS是封装在container中，每一个frame前面是这个frame的长度； SPS的头部是0x67，PPS的头部是0x68，要保持对数据的敏感性。 判断能否都丢帧的依据是，根据NALU包的优先级字节，如果优先级为0，则可以丢弃，如果是IDR、SPS、PPS时，优先级会大于0。 SPS:Sequence Parameter Set 序列参数集，H.264码流第一个 NALU PPS:Picture Parameter Set图像参数集，H.264码流第二个 NALU IDR帧:IDR帧属于I 帧。解码器收到IDR frame时，将所有的参考帧队列丢弃 ，这点是所有I帧共有的特性，但是收到IDR帧时，解码器另外需要做的工作就是：把所有的PPS和SPS参数进行更新。由此可见，在编码器端，每发一个 IDR，就相应地发一个 PPS&amp;SPS_nal_unit I帧:帧内编码帧是一种自带全部信息的独立帧，无需参考其它图像便可独立进行解码，视频序列中的第一个帧始终都是I帧。 P帧:前向预测编码帧 B帧：双向预测内插编码帧 µ]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>H264</tag>
        <tag>视频编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用大全]]></title>
    <url>%2F2018%2F11%2F28%2FGit%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[目录介绍 01.git上传代码步骤 1.1 最简单方法 1.2 常见的命令 02.初始化配置 03.克隆代码库 04.查看代码库信息 05.拉取，提交与推送操作 06.分支操作 07.工作区操作 08.远程同步 01.git简单上传代码步骤1.1 最简单方法 如下所示 1234567891011cd 名称 //进入提交文件目录git add .git commit -m &quot;command&quot; //command提交内容git push origin master提交失败场景：根据提示 “更新被拒绝，因为远程仓库包含您本地尚不存在的提交。由此可知github上面可能和本地的代码不同步，需要把远程服务器的代码更新到本地才行。【可能是网站上更改了某文件导致不同步】解决方法：输入命令git pull即可把github上的代码更新到本地。然后在重新提交如果还是无法提交，可以尝试强制更新git push -u origin +master 1.2 常见的命令02.初始化配置 Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的 Git 配置 $ git config –list 编辑 Git 配置文件 $ git config -e [–global] //–global 表示设置全局配置，不加该参数只对当前仓库生效 设置提交代码时的用户信息 $ git config [–global] user.name “[name]” $ git config [–global] user.email “[email address]” 创建 SSH key $ ssh-keygen -t rsa -C “email@example.com” 此时会生成 id_rsa 和 id_rsa.pub 两个文件，登录网站设置点击 Add SSH Key 在 key 文本里粘贴 id_rsa.pub 文件的内容 关联远程仓库 $ git remote add origin git@github.com:xxx/xxx.git 推送到远程 master 分支 $ git push -u origin master 03.克隆代码库 下载一个项目和它的整个代码历史 $ git clone [url] [url : git@github.com:xxx/xxx.git] 04.查看代码库信息 显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log [–pretty=oneline] //–pretty=oneline 参数可以简化输出信息 显示当前分支的最近几次提交 $ git reflog 显示暂存区和工作区的差异 $ git diff 显示暂存区和上一个commit的差异 $ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 查看文件内容 $ cat [file] 查看分支合并情况 $ git log –graph –pretty=oneline –abbrev-commit 查看分支合并图 $ git log –graph 05.拉取，提交与推送操作 下载远程仓库的所有变动 $ git fetch [remote] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 添加文件到暂存区 $ git add [file1] [file2] … //添加文件名 $ git add [dir] //添加目录 $ git add . //添加当前目录的所有文件(不包括删除文件) $ git add -A //(-A : –all的缩写)添加当前目录的所有文件 提交暂存区到仓库区 $ git commit -m [message] 推送到远程仓库 $ git push [remote] [branch] $ git push [remote] –all $ git push origin(远程仓库名称) master(分支名称) //将master分支上的内容推送到远程仓库，如果远程仓库没有master分支将创建 06.分支操作 查看远程仓库信息 $ git remote -v 列出所有本地分支和远程分支 $ git branch -a 新建一个分支，并切换到该分支 $ git checkout -b [branch]相当于$ git branch [branch-name] //新建一个分支，但依然停留在当前分支 $ git checkout [branch-name] //切换到指定分支，并更新工作区；如果是远程分支将自动与远程关联本地分支 123456789101. 找一个干净目录，假设是git_work2. cd git_work3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录4. cd project5. git branch -a，列出所有分支名称如下：remotes/origin/devremotes/origin/release6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支7. git checkout -b release origin/release，作用参见上一步解释8. git checkout dev，切换回dev分支，并开始开发。 新建一个分支，指向指定 commit $ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 $ git branch –track [branch] [remote-branch] 设置本地分支与远程origin分支链接 $ git branch –set-upstream [branch] origin/[branch] 合并指定分支到当前分支 $ git merge [branch] 查看分支合并情况 $ git log –graph –pretty=oneline –abbrev-commit 查看分支合并图 $ git log –graph 删除分支 $ git branch -d [branch-name] $ git branch -D [branch-name] //强行删除 删除远程分支 $ git push origin –delete [branch-name] $ git branch -dr [remote/branch] 07.工作区操作 查看工作区 $ git stash save [desc] 查看工作区列表 $ git stash list 取出工作区内容 $ git stash apply [stash-name] //取出不删除 $ git stash drop [stash-name] //删除 $ git stash pop [stash-name] //取出并删除 08.远程同步 默认 origin 代表远程仓库 下载远程仓库的所有变动 $ git fetch [remote] 显示所有远程仓库 $ git remote -v 显示某个远程仓库的信息 $ git remote show [remote] 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] –force 推送所有分支到远程仓库 $ git push [remote] –all 09.增加/删除/撤销9.1 增加 添加指定文件到暂存区 $ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录 $ git add [dir] 添加当前目录的所有文件(不包括删除文件)到暂存区 $ git add . 添加当前目录的所有文件到暂存区 $ git add -A(–all的缩写) 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 $ git add -p 9.2 删除 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区 $ git rm –cached [file] 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 9.1 撤销 恢复暂存区的指定文件到工作区 $ git checkout [file] 恢复某个 commit 的指定文件到暂存区和工作区 $ git checkout [commit] [file] 恢复暂存区的所有文件到工作区 $ git checkout . 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset [file] 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset –hard 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset [commit] 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset –hard [commit] 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git reset –keep [commit] 新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView和RecycleView影藏滑动边界效果]]></title>
    <url>%2F2018%2F09%2F15%2Fandroid-2019-02-26-ListView%E5%92%8CRecycleView%E5%BD%B1%E8%97%8F%E6%BB%91%E5%8A%A8%E8%BE%B9%E7%95%8C%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[一、首先是Listview的属性设置设置滑动到顶部和底部的背景或颜色： 12android:overScrollFooter=&quot;@android:color/transparent&quot;android:overScrollHeader=&quot;@android:color/transparent&quot; 设置滑动到边缘时无效果模式： 1android:overScrollMode=&quot;never&quot; 设置滚动条不显示： 1android:scrollbars=&quot;none&quot; 以下是整体设置（overScrollHeader和overScrollFooter可不写，此处写了是引用的透明色） 12345678&lt;ListView android:id="@+id/lv_type" android:layout_width="match_parent" android:layout_height="match_parent" android:overScrollFooter="@android:color/transparent" android:overScrollHeader="@android:color/transparent" android:overScrollMode="never" android:scrollbars="none"&gt; 二、RecyclerView的属性设置以下是整体设置： 123456&lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_search_one" android:layout_width="match_parent" android:layout_height="match_parent" android:overScrollMode="never" android:scrollbars="none" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编译时注解]]></title>
    <url>%2F2018%2F08%2F29%2Fjava-2018-11-29-Java%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 注解处理器 Java中的注解(Annotation)是一个很神奇的东西，特别现在有很多Android库都是使用注解的方式来实现的。一直想详细了解一下其中的原理。很有幸阅读到一篇详细解释编写注解处理器的文章。本文的原文是ANNOTATION PROCESSING 101，作者是Hannes Dorfmann。这是一篇好文，忍不住翻译学习一下。以下是翻译。（注：本文的翻译已经获得了作者 Hannes 的授权。） 在这篇文章中，我将阐述怎样写一个注解处理器(Annotation Processor)。在这篇教程中，首先，我将向您解释什么是注解器，你可以利用这个强大的工具做什么以及不能做什么；然后，我将一步一步实现一个简单的注解器。 一些基本概念在开始之前，我们首先申明一个非常重要的问题：我们并不讨论那些在运行时（Runtime）通过反射机制运行处理的注解，而是讨论在编译时（Compile time）处理的注解。 注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。到这里，我假设你已经知道什么是注解，并且知道怎么申明的一个注解。如果你不熟悉注解，你可以在这官方文档中得到更多信息。注解处理器在Java 5开始就有了，但是从Java 6（2006年12月发布）开始才有可用的API。过了一些时间，Java世界才意识到注解处理器的强大作用，所以它到最近几年才流行起来。 一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是.java文件）作为输出。这具体的含义什么呢？你可以生成Java代码！这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。 虚处理器AbstractProcessor我们首先看一下处理器的API。每一个处理器都是继承于AbstractProcessor，如下所示： 1234567891011121314151617package com.example;public class MyProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; &#125;&#125; init(ProcessingEnvironment env): 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。后面我们将看到详细的内容。 process(Set &lt; ?extends TypeElement &gt; annotations, RoundEnvironment env): 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。 getSupportedAnnotationTypes():这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。 getSupportedSourceVersion(): 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 6的话，你也可以返回SourceVersion.RELEASE_6。我推荐你使用前者。 组合被注解的类一旦我们检查isValidClass()成功，我们将添加FactoryAnnotatedClass到对应的FactoryGroupedClasses中，如下：在Java 7中，你也可以使用注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()，像这样： 123456789101112@SupportedSourceVersion(SourceVersion.latestSupported())@SupportedAnnotationTypes(&#123; // 合法注解全名的集合 &#125;)public class MyProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; &#125;&#125; 因为兼容的原因，特别是针对Android平台，我建议使用重载getSupportedAnnotationTypes()和getSupportedSourceVersion()方法代替@SupportedAnnotationTypes和@SupportedSourceVersion。接下来的你必须知道的事情是，注解处理器是运行它自己的虚拟机JVM中。是的，你没有看错，javac启动一个完整Java虚拟机来运行注解处理器。这对你意味着什么？你可以使用任何你在其他java应用中使用的的东西。使用guava。如果你愿意，你可以使用依赖注入工具，例如dagger或者其他你想要的类库。但是不要忘记，即使是一个很小的处理，你也要像其他Java应用一样，注意算法效率，以及设计模式。 注册你的处理器你可能会问，我怎样将处理器MyProcessor注册到javac中。你必须提供一个.jar文件。就像其他.jar文件一样，你打包你的注解处理器到此文件中。并且，在你的jar中，你需要打包一个特定的文件javax.annotation.processing.Processor到META-INF/services路径下。所以，你的.jar文件看起来就像下面这样： MyProgress.jar com example MyProcessor.class META-INF services javax.annotation.processing.Processor 打包进MyProcessor.jar中的javax.annotation.processing.Processor的内容是，注解处理器的合法的全名列表，每一个元素换行分割： 123com.example.MyProcessor com.foo.OtherProcessor net.blabla.SpecialProcessor 把MyProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册MyProcessor作为注解处理器。 例子：工厂模式开始之前，我必须说，要为这个教程找到一个需要用注解处理器解决的简单问题，实在并不容易。这里我们将实现一个非常简单的工厂模式（不是抽象工厂模式）。这将对注解处理器的API做一个非常简明的介绍。所以，这个问题的程序并不是那么有用，也不是一个真实世界的例子。所以在此申明，你将学习关于注解处理过程的相关内容，而不是设计模式。 我们将要解决的问题是：我们将实现一个披萨店，这个披萨店给消费者提供两种披萨（“Margherita”和“Calzone”）以及提拉米苏甜点(Tiramisu)。 看一下如下的代码，不需要做任何更多的解释： 123456789101112131415161718192021222324public interface Meal &#123; public float getPrice();&#125;public class MargheritaPizza implements Meal &#123; @Override public float getPrice() &#123; return 6.0f; &#125;&#125;public class CalzonePizza implements Meal &#123; @Override public float getPrice() &#123; return 8.5f; &#125;&#125;public class Tiramisu implements Meal &#123; @Override public float getPrice() &#123; return 4.5f; &#125;&#125; 为了在我们的披萨店PizzsStore下订单，消费者需要输入餐(Meal)的名字。 1234567891011121314151617181920212223242526272829public class PizzaStore &#123; public Meal order(String mealName) &#123; if (mealName == null) &#123; throw new IllegalArgumentException(&quot;Name of the meal is null!&quot;); &#125; if (&quot;Margherita&quot;.equals(mealName)) &#123; return new MargheritaPizza(); &#125; if (&quot;Calzone&quot;.equals(mealName)) &#123; return new CalzonePizza(); &#125; if (&quot;Tiramisu&quot;.equals(mealName)) &#123; return new Tiramisu(); &#125; throw new IllegalArgumentException(&quot;Unknown meal &apos;&quot; + mealName + &quot;&apos;&quot;); &#125; public static void main(String[] args) throws IOException &#123; PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(&quot;Bill: $&quot; + meal.getPrice()); &#125;&#125; 正如你所见，在order()方法中，我们有很多的if语句，并且如果我们每添加一种新的披萨，我们都要添加一条新的if语句。但是等一下，使用注解处理和工厂模式，我们可以让注解处理器来帮我们自动生成这些if语句。如此以来，我们期望的是如下的代码： 1234567891011121314public class PizzaStore &#123; private MealFactory factory = new MealFactory(); public Meal order(String mealName) &#123; return factory.create(mealName); &#125; public static void main(String[] args) throws IOException &#123; PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(&quot;Bill: $&quot; + meal.getPrice()); &#125;&#125; MealFactory应该是如下的样子： 123456789101112131415161718192021public class MealFactory &#123; public Meal create(String id) &#123; if (id == null) &#123; throw new IllegalArgumentException(&quot;id is null!&quot;); &#125; if (&quot;Calzone&quot;.equals(id)) &#123; return new CalzonePizza(); &#125; if (&quot;Tiramisu&quot;.equals(id)) &#123; return new Tiramisu(); &#125; if (&quot;Margherita&quot;.equals(id)) &#123; return new MargheritaPizza(); &#125; throw new IllegalArgumentException(&quot;Unknown id = &quot; + id); &#125;&#125; @Factory注解你能猜到么：我们想用注解处理器自动生成MealFactory。更一般的说，我们将想要提供一个注解和一个处理器来生成工厂类。我们先来看一下@Factory注解： 12345678910111213@Target(ElementType.TYPE) @Retention(RetentionPolicy.CLASS)public @interface Factory &#123; /** * 工厂的名字 */ Class type(); /** * 用来表示生成哪个对象的唯一id */ String id();&#125; 想法是这样的：我们将使用同样的type()注解那些属于同一个工厂的类，并且用注解的id()做一个映射，例如从”Calzone”映射到”ClzonePizza”类。我们应用@Factory注解到我们的类中，如下： 12345678910@Factory( id = &quot;Margherita&quot;, type = Meal.class)public class MargheritaPizza implements Meal &#123; @Override public float getPrice() &#123; return 6f; &#125;&#125; 12345678910@Factory( id = &quot;Calzone&quot;, type = Meal.class)public class CalzonePizza implements Meal &#123; @Override public float getPrice() &#123; return 8.5f; &#125;&#125; 12345678910@Factory( id = &quot;Tiramisu&quot;, type = Meal.class)public class Tiramisu implements Meal &#123; @Override public float getPrice() &#123; return 4.5f; &#125;&#125; 你可能会问你自己，我们是否可以只把@Factory注解应用到我们的Meal接口上？答案是，注解是不能继承的。一个类class X被注解，并不意味着它的子类class Y extends X会自动被注解。在我们开始写处理器的代码之前，我们先规定如下一些规则： 1、只有类可以被@Factory注解，因为接口或者抽象类并不能用new操作实例化；2、被@Factory注解的类，必须至少提供一个公开的默认构造器（即没有参数的构造函数）。否者我们没法实例化一个对象。3、被@Factory注解的类必须直接或者间接的继承于type()指定的类型；4、具有相同的type的注解类，将被聚合在一起生成一个工厂类。这个生成的类使用Factory后缀，例如type = Meal.class，将生成MealFactory工厂类；5、id只能是String类型，并且在同一个type组中必须唯一。 处理器我将通过添加代码和一段解释的方法，一步一步的引导你来构建我们的处理器。省略号(…)表示省略那些已经讨论过的或者将在后面的步骤中讨论的代码，目的是为了让我们的代码有更好的可读性。正如我们前面说的，我们完整的代码可以在Github上找到。好了，让我们来看一下我们的处理器类FactoryProcessor的骨架： 1234567891011121314151617181920212223242526272829303132333435@AutoService(Processor.class)public class FactoryProcessor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); typeUtils = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); filer = processingEnv.getFiler(); messager = processingEnv.getMessager(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); annotataions.add(Factory.class.getCanonicalName()); return annotataions; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... &#125;&#125; 你看到在代码的第一行是@AutoService(Processor.class)，这是什么？这是一个其他注解处理器中引入的注解。AutoService注解处理器是Google开发的，用来生成META-INF/services/javax.annotation.processing.Processor文件的。是的，你没有看错，我们可以在注解处理器中使用注解。非常方便，难道不是么？在getSupportedAnnotationTypes()中，我们指定本处理器将处理@Factory注解。 Elements和TypeMirrors在init()中我们获得如下引用： Elements：一个用来处理Element的工具类（后面将做详细说明）； Types：一个用来处理TypeMirror的工具类（后面将做详细说明）； Filer：正如这个名字所示，使用Filer你可以创建文件。 在注解处理过程中，我们扫描所有的Java源文件。源代码的每一个部分都是一个特定类型的Element。换句话说：Element代表程序的元素，例如包、类或者方法。每个Element代表一个静态的、语言级别的构件。在下面的例子中，我们通过注释来说明这个： 12345678910111213package com.example; // PackageElementpublic class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () &#123;&#125; // ExecuteableElement public void setA ( // ExecuteableElement int newA // VariableElement ) &#123;&#125;&#125; 你必须换个角度来看源代码，它只是结构化的文本，他不是可运行的。你可以想象它就像你将要去解析的XML文件一样（或者是编译器中抽象的语法树）。就像XML解释器一样，有一些类似DOM的元素。你可以从一个元素导航到它的父或者子元素上。举例来说，假如你有一个代表public class Foo类的TypeElement元素，你可以遍历它的孩子，如下： 1234TypeElement fooClass = ... ; for (Element e : fooClass.getEnclosedElements())&#123; // iterate over children Element parent = e.getEnclosingElement(); // parent == fooClass&#125; 正如你所见，Element代表的是源代码。TypeElement代表的是源代码中的类型元素，例如类。然而，TypeElement并不包含类本身的信息。你可以从TypeElement中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过TypeMirror获取。你可以通过调用elements.asType()获取元素的TypeMirror。 搜索@Factory注解我们来一步一步实现process()方法。首先，我们从搜索被注解了@Factory的类开始： 1234567891011121314151617181920@AutoService(Processor.class)public class FactoryProcessor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;(); ... @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; // 遍历所有被注解了@Factory的元素 for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; ... &#125; &#125; ...&#125; 这里并没有什么高深的技术。roundEnv.getElementsAnnotatedWith(Factory.class))返回所有被注解了@Factory的元素的列表。你可能已经注意到，我们并没有说“所有被注解了@Factory的类的列表”，因为它真的是返回Element的列表。请记住：Element可以是类、方法、变量等。所以，接下来，我们必须检查这些Element是否是一个类： 123456789101112@Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; // 检查被注解为@Factory的元素是否是一个类 if (annotatedElement.getKind() != ElementKind.CLASS) &#123; ... &#125; &#125; ...&#125; 为什么要这么做？我们要确保只有class元素被我们的处理器处理。前面我们已经学习到类是用TypeElement表示。我们为什么不这样判断呢if (! (annotatedElement instanceof TypeElement) )？这是错误的，因为接口（interface）类型也是TypeElement。所以在注解处理器中，我们要避免使用instanceof，而是配合TypeMirror使用EmentKind或者TypeKind。 错误处理在init()中，我们也获得了一个Messager对象的引用。Messager提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。在官方文档中描述了消息的不同级别。非常重要的是Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了@Factory注解（例如，给接口使用了@Factory注解）。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常Exception。如果你在process()中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器FactoryProcessor第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含FactoryProcessor的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个Messager类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像IntelliJ这种现代的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。 我们重新回到process()方法的实现。如果遇到一个非类类型被注解@Factory，我们发出一个出错信息： 123456789101112131415161718192021public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; // 检查被注解为@Factory的元素是否是一个类 if (annotatedElement.getKind() != ElementKind.CLASS) &#123; error(annotatedElement, &quot;Only classes can be annotated with @%s&quot;, Factory.class.getSimpleName()); return true; // 退出处理 &#125; ... &#125;private void error(Element e, String msg, Object... args) &#123; messager.printMessage( Diagnostic.Kind.ERROR, String.format(msg, args), e); &#125;&#125; 让Messager显示相关出错信息，更重要的是注解处理器程序必须完成运行而不崩溃，这就是为什么在调用error()后直接return。如果我们不直接返回，process()将继续运行，因为messager.printMessage( Diagnostic.Kind.ERROR)不会停止此进程。因此，如果我们在打印错误信息以后不返回的话，我们很可能就会运行到一个NullPointerException等。就像我们前面说的，如果我们继续运行process()，问题是如果在process()中抛出一个未处理的异常，javac将会打印出内部的NullPointerException，而不是Messager中的错误信息。 数据模型在继续检查被注解@Fractory的类是否满足我们上面说的5条规则之前，我们将介绍一个让我们更方便继续处理的数据结构。有时候，一个问题或者解释器看起来如此简单，以至于程序员倾向于用一个面向过程方式来写整个处理器。但是你知道吗？一个注解处理器任然是一个Java程序，所以我们需要使用面向对象编程、接口、设计模式，以及任何你将在其他普通Java程序中使用的技巧。我们的FactoryProcessor非常简单，但是我们仍然想要把一些信息存为对象。在FactoryAnnotatedClass中，我们保存被注解类的数据，比如合法的类的名字，以及@Factory注解本身的一些信息。所以，我们保存TypeElement和处理过的@Factory注解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class FactoryAnnotatedClass &#123; private TypeElement annotatedClassElement; private String qualifiedSuperClassName; private String simpleTypeName; private String id; public FactoryAnnotatedClass(TypeElement classElement) throws IllegalArgumentException &#123; this.annotatedClassElement = classElement; Factory annotation = classElement.getAnnotation(Factory.class); id = annotation.id(); if (StringUtils.isEmpty(id)) &#123; throw new IllegalArgumentException( String.format(&quot;id() in @%s for class %s is null or empty! that&apos;s not allowed&quot;, Factory.class.getSimpleName(), classElement.getQualifiedName().toString())); &#125; // Get the full QualifiedTypeName try &#123; Class&lt;?&gt; clazz = annotation.type(); qualifiedSuperClassName = clazz.getCanonicalName(); simpleTypeName = clazz.getSimpleName(); &#125; catch (MirroredTypeException mte) &#123; DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement(); qualifiedSuperClassName = classTypeElement.getQualifiedName().toString(); simpleTypeName = classTypeElement.getSimpleName().toString(); &#125; &#125; /** * 获取在&#123;@link Factory#id()&#125;中指定的id * return the id */ public String getId() &#123; return id; &#125; /** * 获取在&#123;@link Factory#type()&#125;指定的类型合法全名 * * @return qualified name */ public String getQualifiedFactoryGroupName() &#123; return qualifiedSuperClassName; &#125; /** * 获取在 &#123;@link Factory#type()&#125; 中指定的类型的简单名字 * * @return qualified name */ public String getSimpleFactoryGroupName() &#123; return simpleTypeName; &#125; /** * 获取被@Factory注解的原始元素 */ public TypeElement getTypeElement() &#123; return annotatedClassElement; &#125;&#125; 代码很多，但是最重要的部分是在构造函数中。其中你能找到如下的代码： 12345678Factory annotation = classElement.getAnnotation(Factory.class); id = annotation.id(); // Read the id value (like &quot;Calzone&quot; or &quot;Tiramisu&quot;)if (StringUtils.isEmpty(id)) &#123; throw new IllegalArgumentException( String.format(&quot;id() in @%s for class %s is null or empty! that&apos;s not allowed&quot;, Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));&#125; 这里我们获取@Factory注解，并且检查id是否为空？如果为空，我们将抛出IllegalArgumentException异常。你可能感到疑惑的是，前面我们说了不要抛出异常，而是使用Messager。这里仍然不矛盾。我们抛出内部的异常，你在将在后面看到会在process()中捕获这个异常。我这样做出于一下两个原因： 1、我想示意我们应该像普通的Java程序一样编码。抛出和捕获异常是非常好的Java编程实践；2、如果我们想要在FactoryAnnotatedClass中打印信息，我需要也传入Messager对象，并且我们在错误处理一节中已经提到，为了打印Messager信息，我们必须成功停止处理器运行。如果我们使用Messager打印了错误信息，我们怎样告知process()出现了错误呢？最容易，并且我认为最直观的方式就是抛出一个异常，然后让process()捕获之。接下来，我们将获取@Fractory注解中的type成员。我们比较关心的是合法的全名： 12345678910try &#123; Class&lt;?&gt; clazz = annotation.type(); qualifiedGroupClassName = clazz.getCanonicalName(); simpleFactoryGroupName = clazz.getSimpleName();&#125; catch (MirroredTypeException mte) &#123; DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement(); qualifiedGroupClassName = classTypeElement.getQualifiedName().toString(); simpleFactoryGroupName = classTypeElement.getSimpleName().toString();&#125; 这里有一点小麻烦，因为这里的类型是一个java.lang.Class。这就意味着，他是一个真正的Class对象。因为注解处理是在编译Java源代码之前。我们需要考虑如下两种情况： 1、这个类已经被编译：这种情况是：如果第三方.jar包含已编译的被@Factory注解.class文件。在这种情况下，我们可以想try中那块代码中所示直接获取Class。2、这个还没有被编译：这种情况是我们尝试编译被@Fractory注解的源代码。这种情况下，直接获取Class会抛出MirroredTypeException异常。幸运的是，MirroredTypeException包含一个TypeMirror，它表示我们未编译类。因为我们已经知道它必定是一个类类型（我们已经在前面检查过），我们可以直接强制转换为DeclaredType，然后读取TypeElement来获取合法的名字。好了，我们现在还需要一个数据结构FactoryGroupedClasses，它将简单的组合所有的FactoryAnnotatedClasses到一起。 12345678910111213141516171819202122232425public class FactoryGroupedClasses &#123; private String qualifiedClassName; private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap = new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;(); public FactoryGroupedClasses(String qualifiedClassName) &#123; this.qualifiedClassName = qualifiedClassName; &#125; public void add(FactoryAnnotatedClass toInsert) throws IdAlreadyUsedException &#123; FactoryAnnotatedClass existing = itemsMap.get(toInsert.getId()); if (existing != null) &#123; throw new IdAlreadyUsedException(existing); &#125; itemsMap.put(toInsert.getId(), toInsert); &#125; public void generateCode(Elements elementUtils, Filer filer) throws IOException &#123; ... &#125;&#125; 正如你所见，这是一个基本的Map，这个映射表用来映射@Factory.id()到FactoryAnnotatedClass。我们选择Map这个数据类型，是因为我们要确保每个id是唯一的，我们可以很容易通过map查找实现。generateCode()方法将被用来生成工厂类代码（将在后面讨论）。 匹配标准我们继续实现process()方法。接下来我们想要检查被注解的类必须有只要一个公开的构造函数，不是抽象类，继承于特定的类型，以及是一个公开类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class FactoryProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123; ... // 因为我们已经知道它是ElementKind.CLASS类型，所以可以直接强制转换 TypeElement typeElement = (TypeElement) annotatedElement; try &#123; FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException if (!isValidClass(annotatedClass)) &#123; return true; // 已经打印了错误信息，退出处理过程 &#125; &#125; catch (IllegalArgumentException e) &#123; // @Factory.id()为空 error(typeElement, e.getMessage()); return true; &#125; ... &#125; private boolean isValidClass(FactoryAnnotatedClass item) &#123; // 转换为TypeElement, 含有更多特定的方法 TypeElement classElement = item.getTypeElement(); if (!classElement.getModifiers().contains(Modifier.PUBLIC)) &#123; error(classElement, &quot;The class %s is not public.&quot;, classElement.getQualifiedName().toString()); return false; &#125; // 检查是否是一个抽象类 if (classElement.getModifiers().contains(Modifier.ABSTRACT)) &#123; error(classElement, &quot;The class %s is abstract. You can&apos;t annotate abstract classes with @%&quot;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName()); return false; &#125; // 检查继承关系: 必须是@Factory.type()指定的类型子类 TypeElement superClassElement = elementUtils.getTypeElement(item.getQualifiedFactoryGroupName()); if (superClassElement.getKind() == ElementKind.INTERFACE) &#123; // 检查接口是否实现了 if(!classElement.getInterfaces().contains(superClassElement.asType())) &#123; error(classElement, &quot;The class %s annotated with @%s must implement the interface %s&quot;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; &#125; &#125; else &#123; // 检查子类 TypeElement currentClass = classElement; while (true) &#123; TypeMirror superClassType = currentClass.getSuperclass(); if (superClassType.getKind() == TypeKind.NONE) &#123; // 到达了基本类型(java.lang.Object), 所以退出 error(classElement, &quot;The class %s annotated with @%s must inherit from %s&quot;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; &#125; if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) &#123; // 找到了要求的父类 break; &#125; // 在继承树上继续向上搜寻 currentClass = (TypeElement) typeUtils.asElement(superClassType); &#125; &#125; // 检查是否提供了默认公开构造函数 for (Element enclosed : classElement.getEnclosedElements()) &#123; if (enclosed.getKind() == ElementKind.CONSTRUCTOR) &#123; ExecutableElement constructorElement = (ExecutableElement) enclosed; if (constructorElement.getParameters().size() == 0 &amp;&amp; constructorElement.getModifiers() .contains(Modifier.PUBLIC)) &#123; // 找到了默认构造函数 return true; &#125; &#125; &#125; // 没有找到默认构造函数 error(classElement, &quot;The class %s must provide an public empty default constructor&quot;, classElement.getQualifiedName().toString()); return false; &#125;&#125; 我们这里添加了isValidClass()方法，来检查是否我们所有的规则都被满足了： 必须是公开类：classElement.getModifiers().contains(Modifier.PUBLIC) 必须是非抽象类：classElement.getModifiers().contains(Modifier.ABSTRACT) 必须是@Factoy.type()指定的类型的子类或者接口的实现：首先我们使用elementUtils.getTypeElement(item.getQualifiedFactoryGroupName())创建一个传入的Class(@Factoy.type())的元素。是的，你可以仅仅通过已知的合法类名来直接创建TypeElement（使用TypeMirror）。接下来我们检查它是一个接口还是一个类：superClassElement.getKind() == ElementKind.INTERFACE。所以我们这里有两种情况：如果是接口，就判断classElement.getInterfaces().contains(superClassElement.asType())；如果是类，我们就必须使用currentClass.getSuperclass()扫描继承层级。注意，整个检查也可以使用typeUtils.isSubtype()来实现。 类必须有一个公开的默认构造函数：我们遍历所有的闭元素classElement.getEnclosedElements()，然后检查ElementKind.CONSTRUCTOR、Modifier.PUBLIC以及constructorElement.getParameters().size() == 0。 如果所有这些条件都满足，isValidClass()返回true，否者就打印错误信息，并且返回false。 组合被注解的类一旦我们检查isValidClass()成功，我们将添加FactoryAnnotatedClass到对应的FactoryGroupedClasses中，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FactoryProcessor extends AbstractProcessor &#123; private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;(); @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... try &#123; FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException if (!isValidClass(annotatedClass)) &#123; return true; // 错误信息被打印，退出处理流程 &#125; // 所有检查都没有问题，所以可以添加了 FactoryGroupedClasses factoryClass = factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName()); if (factoryClass == null) &#123; String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName(); factoryClass = new FactoryGroupedClasses(qualifiedGroupName); factoryClasses.put(qualifiedGroupName, factoryClass); &#125; // 如果和其他的@Factory标注的类的id相同冲突， // 抛出IdAlreadyUsedException异常 factoryClass.add(annotatedClass); &#125; catch (IllegalArgumentException e) &#123; // @Factory.id()为空 --&gt; 打印错误信息 error(typeElement, e.getMessage()); return true; &#125; catch (IdAlreadyUsedException e) &#123; FactoryAnnotatedClass existing = e.getExisting(); // 已经存在 error(annotatedElement, &quot;Conflict: The class %s is annotated with @%s with id =&apos;%s&apos; but %s already uses the same id&quot;, typeElement.getQualifiedName().toString(), Factory.class.getSimpleName(), existing.getTypeElement().getQualifiedName().toString()); return true; &#125; &#125; ...&#125; 代码生成我们已经收集了所有的被@Factory注解的类保存到为FactoryAnnotatedClass，并且组合到了FactoryGroupedClasses。现在我们将为每个工厂生成Java文件了： 12345678910111213@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... try &#123; for (FactoryGroupedClasses factoryClass : factoryClasses.values()) &#123; factoryClass.generateCode(elementUtils, filer); &#125; &#125; catch (IOException e) &#123; error(null, e.getMessage()); &#125; return true;&#125; 写Java文件，和写其他普通文件没有什么两样。使用Filer提供的Writer对象，我们可以连接字符串来写我们生成的Java代码。幸运的是，Square公司（因为提供了许多非常优秀的开源项目二非常有名）给我们提供了JavaWriter，这是一个高级的生成Java代码的库： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class FactoryGroupedClasses &#123; /** * 将被添加到生成的工厂类的名字中 */ private static final String SUFFIX = &quot;Factory&quot;; private String qualifiedClassName; private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap = new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;(); ... public void generateCode(Elements elementUtils, Filer filer) throws IOException &#123; TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName); String factoryClassName = superClassName.getSimpleName() + SUFFIX; JavaFileObject jfo = filer.createSourceFile(qualifiedClassName + SUFFIX); Writer writer = jfo.openWriter(); JavaWriter jw = new JavaWriter(writer); // 写包名 PackageElement pkg = elementUtils.getPackageOf(superClassName); if (!pkg.isUnnamed()) &#123; jw.emitPackage(pkg.getQualifiedName().toString()); jw.emitEmptyLine(); &#125; else &#123; jw.emitPackage(&quot;&quot;); &#125; jw.beginType(factoryClassName, &quot;class&quot;, EnumSet.of(Modifier.PUBLIC)); jw.emitEmptyLine(); jw.beginMethod(qualifiedClassName, &quot;create&quot;, EnumSet.of(Modifier.PUBLIC), &quot;String&quot;, &quot;id&quot;); jw.beginControlFlow(&quot;if (id == null)&quot;); jw.emitStatement(&quot;throw new IllegalArgumentException(\&quot;id is null!\&quot;)&quot;); jw.endControlFlow(); for (FactoryAnnotatedClass item : itemsMap.values()) &#123; jw.beginControlFlow(&quot;if (\&quot;%s\&quot;.equals(id))&quot;, item.getId()); jw.emitStatement(&quot;return new %s()&quot;, item.getTypeElement().getQualifiedName().toString()); jw.endControlFlow(); jw.emitEmptyLine(); &#125; jw.emitStatement(&quot;throw new IllegalArgumentException(\&quot;Unknown id = \&quot; + id)&quot;); jw.endMethod(); jw.endType(); jw.close(); &#125;&#125; 注意：因为JavaWriter非常非常的流行，所以很多处理器、库、工具都依赖于JavaWriter。如果你使用依赖管理工具，例如maven或者gradle，假如一个库依赖的JavaWriter的版本比其他的库新，这将会导致一些问题。所以我建议你直接拷贝重新打包JavaWiter到你的注解处理器代码中（实际它只是一个Java文件）。 更新：JavaWrite现在已经被JavaPoet取代了。 https://race604.com/annotation-processing/ 处理循环注解处理过程可能会多于一次。官方javadoc定义处理过程如下： 注解处理过程是一个有序的循环过程。在每次循环中，一个处理器可能被要求去处理那些在上一次循环中产生的源文件和类文件中的注解。第一次循环的输入是运行此工具的初始输入。这些初始输入，可以看成是虚拟的第0此的循环的输出。 一个简单的定义：一个处理循环是调用一个注解处理器的process()方法。对应到我们的工厂模式的例子中：FactoryProcessor被初始化一次（不是每次循环都会新建处理器对象），然而，如果生成了新的源文件process()能够被调用多次。听起来有点奇怪不是么？原因是这样的，这些生成的文件中也可能包含@Factory注解，它们还将会被FactoryProcessor处理。例如我们的PizzaStore的例子中将会经过3次循环处理： Round Input output 1 CalzonePizza.java Tiramisu.java MargheritaPizza.java Meal.java PizzaStore.java MealFactory.java 2 MealFactory.java — none — 3 — none — — none — 我解释处理循环还有另外一个原因。如果你看一下我们的FactoryProcessor代码你就能注意到，我们收集数据和保存它们在一个私有的域中Map factoryClasses。在第一轮中，我们检测到了MagheritaPizza, CalzonePizza和Tiramisu，然后生成了MealFactory.java。在第二轮中把MealFactory作为输入。因为在MealFactory中没有检测到@Factory注解，我们预期并没有错误，然而我们得到如下的信息： 1Attempt to recreate a file for type com.hannesdorfmann.annotationprocessing101.factory.MealFactory 这个问题是因为我们没有清除factoryClasses，这意味着，在第二轮的process()中，任然保存着第一轮的数据，并且会尝试生成在第一轮中已经生成的文件，从而导致这个错误的出现。在我们的这个场景中，我们知道只有在第一轮中检查@Factory注解的类，所以我们可以简单的修复这个问题，如下： 12345678910111213141516@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; try &#123; for (FactoryGroupedClasses factoryClass : factoryClasses.values()) &#123; factoryClass.generateCode(elementUtils, filer); &#125; // 清除factoryClasses factoryClasses.clear(); &#125; catch (IOException e) &#123; error(null, e.getMessage()); &#125; ... return true;&#125; 我知道这有其他的方法来处理这个问题，例如我们也可以设置一个布尔值标签等。关键的点是：我们要记住注解处理过程是需要经过多轮处理的，并且你不能重载或者重新创建已经生成的源代码。 分离处理器和注解如果你已经看了我们的代码库，你将发现我们组织我们的代码到两个maven模块中了。我们这么做是因为，我们想让我们的工厂模式的例子的使用者，在他们的工程中只编译注解，而包含处理器模块只是为了编译。有点晕？我们举个例子，如果我们只有一个包。如果另一个开发者想要把我们的工厂模式处理器用于他的项目中，他就必须包含@Factory注解和整个FactoryProcessor的代码（包括FactoryAnnotatedClass和FactoryGroupedClasses）到他们项目中。我非常确定的是，他并不需要在他已经编译好的项目中包含处理器相关的代码。如果你是一个Android的开发者，你肯定听说过65k个方法的限制（即在一个.dex文件中，只能寻址65000个方法）。如果你在FactoryProcessor中使用guava，并且把注解和处理器打包在一个包中，这样的话，Android APK安装包中不只是包含FactoryProcessor的代码，而也包含了整个guava的代码。Guava有大约20000个方法。所以分开注解和处理器是非常有意义的。 生成的类的实例化你已经看到了，在这个PizzaStore的例子中，生成了MealFactory类，它和其他手写的Java类没有任何区别。进而，你需要就想其他Java对象，手动实例化 它： 123456789public class PizzaStore &#123; private MealFactory factory = new MealFactory(); public Meal order(String mealName) &#123; return factory.create(mealName); &#125; ...&#125; 如果你是一个Android的开发者，你应该也非常熟悉一个叫做ButterKnife的注解处理器。在ButterKnife中，你使用@InjectView注解Android的View。ButterKnifeProcessor生成一个MyActivity$$ViewInjector，但是在ButterKnife你不需要手动调用new MyActivity$$ViewInjector()实例化一个ButterKnife注入的对象，而是使用Butterknife.inject(activity)。ButterKnife内部使用反射机制来实例化MyActivity$$ViewInjector()对象： 123try &#123; Class&lt;?&gt; injector = Class.forName(clsName + &quot;$$ViewInjector&quot;);&#125; catch (ClassNotFoundException e) &#123; ... &#125; 但是反射机制不是很慢么，我们使用注解处理来生成本地代码，会不会导致很多的反射性能的问题？的确，反射机制的性能确实是一个问题。然而，它不需要手动去创建对象，确实提高了开发者的开发速度。ButterKnife中有一个哈希表HashMap来缓存实例化过的对象。所以MyActivity$$ViewInjector只是使用反射机制实例化一次，第二次需要MyActivity$$ViewInjector的时候，就直接冲哈希表中获得。 FragmentArgs非常类似于ButterKnife。它使用反射机制来创建对象，而不需要开发者手动来做这些。FragmentArgs在处理注解的时候生成一个特别的查找表类，它其实就是一种哈希表，所以整个FragmentArgs库只是在第一次使用的时候，执行一次反射调用，一旦整个Class.forName()的Fragemnt的参数对象被创建，后面的都是本地代码运行了。 作为一个注解注解处理器的开发者，这些都由你来决定，为其他的注解器使用者，在反射和可用性上找到一个好的平衡。 总结到此，我希望你对注解处理过程有一个非常深刻的理解。我必须再次说明一下：注解处理器是一个非常强大的工具，减少了很多无聊的代码的编写。我也想提醒的是，注解处理器可以做到比我上面提到的工厂模式的例子复杂很多的事情。例如，泛型的类型擦除，因为注解处理器是发生在类型擦除（type erasure）之前的（译者注：类型擦除可以参考这里）。就像你所看到的，你在写注解处理的时候，有两个普遍的问题你需要处理：第一问题， 如果你想在其他类中使用ElementUtils, TypeUtils和Messager，你就必须把他们作为参数传进去。在我为Android开发的注解器AnnotatedAdapter中，我尝试使用Dagger（一个依赖注入库）来解决这个问题。在这个简单的处理中使用它听起来有点过头了，但是它确实很好用；第二个问题，你必须做查询Elements的操作。就想我之前提到的，处理Element就解析XML或者HTML一样。对于HTML你可以是用jQuery，如果在注解处理器中，有类似于jQuery的库那那绝对是酷毙了。如果你知道有类似的库，请在下面的评论告诉我。 请注意的是，在FactoryProcessor代码中有一些缺陷和陷阱。这些“错误”是我故意放进去的，是为了演示一些在开发过程中的常见错误（例如“Attempt to recreate a file”）。如果你想基于FactoryProcessor写你自己注解处理器，请不要直接拷贝粘贴这些陷阱过去，你应该从最开始就避免它们。 我在后续的博客中将会写注解处理器的单元测试，敬请关注。 µ]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解详解]]></title>
    <url>%2F2018%2F08%2F29%2Fjava-2018-11-29-Java%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、基本概述 Annontation是Java5开始引入的新特征。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。更通俗的意思是为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 二、原理 Annotation其实是一种接口。通过Java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类即使用注解的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。 Annoation和程序代码的隔离性：Annotation是不会影响程序代码的执行，无论Annotation怎么变化，代码都始终如一地执行。 忽略性：Java语言解释器在工作时会忽略这些annotation，因此在JVM 中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annontaion类型的信息进行访问和处理。 Annotation与interface的异同： Annotation类型使用关键字@interface而不是interface。这个关键字声明隐含了一个信息：它是继承了java.lang.annotation.Annotation接口，并非声明了一个interface。 Annotation类型、方法定义是独特的、受限制的。 Annotation 类型的方法必须声明为无参数、无异常抛出的。 这些方法定义了Annotation的成员：方法名成为了成员名，而方法返回值成为了成员的类型。方法返回值类型必须为primitive类型、Class类型、枚举类型、annotation类型或者由前面类型之一作为元素的一维数组。方法的后面可以使用 default和一个默认数值来声明成员的默认值，null不能作为成员默认值，这与我们在非Annotation类型中定义方法有很大不同。 Annotation类型和它的方法不能使用Annotation类型的参数、成员不能是generic。只有返回值类型是Class的方法可以在Annotation类型中使用generic，因为此方法能够用类转换将各种类型转换为Class。 Annotation类型又与接口有着近似之处。 它们可以定义常量、静态成员类型（比如枚举类型定义）。Annotation类型也可以如接口一般被实现或者继承。 三、注解的定义 注解通过 @interface 关键字进行定义。 12public @interface TestAnnotation &#123;&#125; 它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。 四、元注解 元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。示例：123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; @Documented顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。 @TargetTarget 是目标的意思，@Target 指定了注解运用的地方。 你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。 类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。1234567@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 解释：当A类被Test注解后，B 继承A , B就拥有了这个注解 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。 123456789101112131415@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;artist&quot;)@Person(role=&quot;coder&quot;)@Person(role=&quot;PM&quot;)public class SuperMan&#123;&#125; 注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。 什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。 我们再看看代码中的相关容器注解。123@interface Persons &#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。 https://blog.csdn.net/briblue/article/details/73824058 五、内建注解Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings这3个注解。 5.1 @Override源码：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 用途：用于告知编译器，我们需要覆写超类的当前方法。注解类型分析：@Override可适用元素为方法，仅仅保留在java源文件中。 5.2 @Deprecated (不赞成使用)123456789101112131415/** * A program element annotated &amp;#64;Deprecated is one that programmers * are discouraged from using, typically because it is dangerous, * or because a better alternative exists. Compilers warn when a * deprecated program element is used or overridden in non-deprecated code. * * @author Neal Gafter * @since 1.5 * @jls 9.6.3.6 @Deprecated */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 用途：用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用时，应该使用这个注解。Java在javadoc中推荐使用该注解，一般应该提供为什么该方法不推荐使用以及相应替代方法。注解类型分析： @Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时VM。 5.3 @SuppressWarnings源码123456@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 用于：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型。注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。该注解有方法value(）,可支持多个字符串参数，例如： 1@SupressWarning(value=&#123;&quot;uncheck&quot;,&quot;deprecation&quot;&#125;) 前面讲的@Override，@Deprecated都是无需参数的，而压制警告是需要带有参数的，可用参数如下： 参数 含义 deprecation 使用了过时的类或方法时的警告 unchecked 执行了未检查的转换时的警告 fallthrough 当Switch程序块进入进入下一个case而没有Break时的警告 path 在类路径、源文件路径等有不存在路径时的警告 serial 当可序列化的类缺少serialVersionUID定义时的警告 finally 任意finally子句不能正常完成时的警告 all 以上所有情况 六 自定义注解注解123456789@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface People &#123; String name() default &quot;&quot;; int age() default 0;&#125; 反射获取值 123456789101112131415161718192021public class Test &#123; @People(name = &quot;kk&quot;,age = 99) private static String people; public static void main(String args[])&#123; try &#123; Class classz = Test.class.getClassLoader().loadClass(&quot;Test&quot;); Field[] declaredFields = classz.getDeclaredFields(); for (Field file: declaredFields) &#123; People annotation = file.getAnnotation(People.class); System.out.println(annotation.name() +&quot;----&quot;+ annotation.age()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果kk----99]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB命令大全]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: "android.intent.action.MAIN" Category: "android.intent.category.LAUNCHER" AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125; applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125; codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125; flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125; installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es "toast" "hello, world" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令：1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed "s/\r$//" &gt; sc.png Mac OS X 1adb shell screencap -p | gsed "s/\r$//" &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid="TP-LINK_9DFC" scan_ssid=1 psk="123456789" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid="TP-LINK_F11E" psk="987654321" key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server&apos;s $ADB_VENDOR_KEYS is not setTry &apos;adb kill-server&apos; if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker数据卷操作]]></title>
    <url>%2F2018%2F06%2F16%2Flinux-2018-06-16-docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据卷操作选择 -v 还是 -–mount 参数Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。 创建一个数据卷1$ docker volume create my-vol 查看所有数据卷123mk:~ mk$ docker volume lsDRIVER VOLUME NAMElocal nexus-data 查看数据卷详细信息123456789101112mk:~ mk$ docker volume inspect nexus-data[ &#123; &quot;CreatedAt&quot;: &quot;2018-05-09T05:47:13Z&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nexus-data/_data&quot;, &quot;Name&quot;: &quot;nexus-data&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] 启动一个挂载数据卷的容器在用 docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。 123456$ docker run -d -P \ --name web \ # -v my-vol:/wepapp \ --mount source=my-vol,target=/webapp \ training/webapp \ python app.py 查看数据卷的具体信息在主机里使用以下命令可以查看 web 容器的信息 1$ docker inspect web 数据卷 信息在 “Mounts” Key 下面 123456789101112&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Destination&quot;: &quot;/app&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125;], 删除数据卷1docker volume rm my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 1$ docker volume prune]]></content>
      <categories>
        <category>服务器</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB备份数据]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[mongoDB 备份数据mongodump 是 MongoDB 提供的一个工具，用于备份数据库，配合使用 mongorestore 恢复工具使用。这套工具适合小型应用或开发环境。 运行 mongodump 和 mongorestore 时需要读取正在运行的数据库实例，因此会影响数据库性能。一方面是运行时需要占用系统资源，另一方面，运行这两个命令时数据库会强制通过内存读取所有数据，可能导致读取的不常用数据覆盖常用数据，从而影响数据库日常运行的性能。2.2及以上版本的 mongodump 数据格式与低版本不兼容，因此请勿使用高版本工具备份低版本数据。mongodump 不会备份 local 数据库。 直接运行 mongodump 命令，默认备份本地运行在27017端口下的 MongoDB 实例中的所有数据库（local 除外），并在当前目录下生成 dump/ 路径存放备份文件。你也可以使用以下命令指定备份的数据库位置、端口、输出文件位置、备份数据库和文档： 语法如下1&gt; mongodump -h dbhost -d dbname -o dbdirectory -u user -p password -h MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d 需要备份的数据库实例，例如：test -o 备份的数据存放位置，例如：c:datadump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 -u -p 如果有设置用户和密码，需要设置对应的用户名和密码，否则没有权限 一、编写脚本123456789101112131415161718192021222324252627#!/bin/sh# dump 命令执行路径，根据mongodb安装路径而定DUMP=/usr/bin/mongodump# 临时备份路径OUT_DIR=/home/backup/mongod_bak/mongod_bak_now# 压缩后的备份存放路径TAR_DIR=/home/backup/mongod_bak/mongod_bak_list# 当前系统时间DATE=`date +%Y-%m-%d`# 数据库账号DB_USER=user# 数据库密码DB_PASS=password# 代表删除7天前的备份，即只保留近 7 天的备份DAYS=7# 最终保存的数据库备份文件TAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot;cd $OUT_DIRrm -rf $OUT_DIR/*mkdir -p $OUT_DIR/$DATE$DUMP -h 127.0.0.1:27017 -u $DB_USER -p $DB_PASS -d dbname -o $OUT_DIR/$DATE# 压缩格式为 .tar.gz 格式tar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE# 删除 15 天前的备份文件find $TAR_DIR/ -mtime +$DAYS -deleteexit 二、创建对应的目录12mkdir /home/backup/mongod_bak/mongod_bak_nowmkdir /home/backup/mongod_bak/mongod_bak_list 三、设置只执行1chmod +x mongod_bak.sh 四、利用系统工具定期执行命令1vim /etc/crontab 如果没有这个文件 我的是docker容器 1apt-get install cron 在底部添加 10 2 * * * root ~/crontab/mongod_bak.sh 基本格式 :command分 时 日 月 周 命令 第1列表示分钟1～59 每分钟用或者 /1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天） 示例： 123456# m h dom mon dow user command17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )* 18 * * * root cd /data/mongodb_time_bak/ &amp;&amp; ./mongodb_bak.sh 五、开启定时服务1service crond start]]></content>
      <categories>
        <category>服务器</category>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux定时任务（crontab）]]></title>
    <url>%2F2018%2F06%2F16%2Flinux-2018-06-16-Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88crontab%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、什么是例行性工作调度 每个人或多或少都有一些约会或者是工作，有的工作是例行性的， 例如每年一次的加薪、每 个月一次的工作报告、每周一次的午餐会报、每天需要的打卡等等； 有的工作则是临时发生 的，例如刚好总公司有高官来访，需要你准备演讲器材等等！ 用在生活上面，例如每年的爱 人的生日、每天的起床时间等等、还有突发性的 3C 用品大降价 （啊！真希望天天都有！） 等等啰。像上面这些例行性工作，通常你得要记录在行事历上面才能避免忘记！不过，由于我们常常 在计算机前面的缘故， 如果计算机系统能够主动的通知我们的话，那么不就轻松多了！嘿 嘿！这个时候 Linux 的例行性工作调度就可以派上场了！ 在不考虑硬件与我们服务器的链接 状态下，我们的 Linux 可以帮你提醒很多任务，例如：每一天早上 8:00 钟要服务器连接上音 响，并启动音乐来唤你起床；而中午 12:00 希望 Linux 可以发一封信到你的邮件信箱，提醒 你可以去吃午餐了； 另外，在每年的你爱人生日的前一天，先发封信提醒你，以免忘记这么 重要的一天。那么 Linux 的例行性工作是如何进行调度的呢？所谓的调度就是将这些工作安排执行的流程 之意！ 咱们的 Linux 调度就是通过 crontab 与 at 这两个东西！这两个玩意儿有啥异同？就让 我们来瞧瞧先！ 2、crond 服务读取配置文件的位置 一般来说，crond 默认有三个地方会有执行脚本配置文件，他们分别是： /etc/crontab /etc/cron.d/* /var/spool/cron/* 这三个地方中，跟系统的运行比较有关系的两个配置文件是放在 /etc/crontab 文件内以及 /etc/cron.d/* 目录内的文件， 另外一个是跟用户自己的工作比较有关的配置文件，就是放在 /var/spool/cron/ 里面的文件群。 3、crontab 简介crontab ：crontab 这个指令所设置的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。 至于让 crontab 可以生效的服务则是 crond 这个服务喔！ crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 Linux下的任务调度分为两类，系统任务调度和用户任务调度。系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。/etc/crontab文件包括下面几行(里面的内容下面讲解)： 1234567891011121314# /etc/crontab: system-wide crontab# Unlike any other crontab you don&apos;t have to run the `crontab&apos;# command to install the new version when you edit this file# and files in /etc/cron.d. These files also have username fields,# that none of the other crontabs do.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# m h dom mon dow user command17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly ) 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。 上面时间格式解释 cron控制 安装crontab：yum install crontabs服务操作说明：/sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置查看crontab服务状态：service crond status手动启动crontab服务：service crond start]]></content>
      <categories>
        <category>服务器</category>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[du命令查看磁盘文件夹大小]]></title>
    <url>%2F2018%2F06%2F16%2Flinux-2018-06-16-du%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[df du命令查看磁盘文件夹大小 df命令是linux系统以磁盘分区为单位查看文件系统，可以加上参数查看磁盘剩余空间信息，命令格式命令 ： df -hl 12345678910文件系统 容量 已用 可用 已用% 挂载点/dev/root 7.2G 5.1G 1.8G 74% /devtmpfs 458M 0 458M 0% /devtmpfs 462M 0 462M 0% /dev/shmtmpfs 462M 6.9M 455M 2% /runtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 462M 0 462M 0% /sys/fs/cgroup/dev/mmcblk0p1 42M 21M 21M 51% /boottmpfs 93M 0 93M 0% /run/user/1000/dev/sdb3 917G 38G 833G 5% /media/pi/pi-data 常用的命令df -hl 查看磁盘剩余空间df -h 查看每个根路径的分区大小df –help 帮助 du -sh [目录名] 返回该目录的大小du -sm [文件夹] 返回该文件夹总M数du –help 帮助 du help 翻译123456789101112131415161718192021222324252627282930313233343536373839404142434445用法：du [选项]... [文件]...或：du [选项]... --files0-from=F，计算每个文件的磁盘用量，目录则取总用量。 长选项必须使用的参数对于短选项时也是必需使用的。 -a, --all 输出所有文件的磁盘用量，不仅仅是目录 --apparent-size 显示表面用量，而并非是磁盘用量；虽然表面用量通常会 小一些，但有时它会因为稀疏文件间的&quot;洞&quot;、内部碎片、非直接引用的块等原因而变大。 -B, --block-size=大小 使用指定字节数的块 -b, --bytes 等于--apparent-size --block-size=1 -c, --total 显示总计信息 -D, --dereference-args 解除命令行中列出的符号连接 --files0-from=F 计算文件F 中以NUL 结尾的文件名对应占用的磁盘空间 如果F 的值是&quot;-&quot;，则从标准输入读入文件名 -H 等于--dereference-args (-D) -h, --human-readable 以可读性较好的方式显示尺寸(例如：1K 234M 2G) --si 类似-h，但在计算时使用1000 为基底而非1024 -k 等于--block-size=1K -l, --count-links 如果是硬连接，就多次计算其尺寸 -m 等于--block-size=1M -L, --dereference 找出任何符号链接指示的真正目的地 -P, --no-dereference 不跟随任何符号链接(默认) -0, --null 将每个空行视作0 字节而非换行符 -S, --separate-dirs 不包括子目录的占用量 -s, --summarize 只分别计算命令列中每个参数所占的总用量 -x, --one-file-system 跳过处于不同文件系统之上的目录 -X, --exclude-from=文件 排除与指定文件中描述的模式相符的文件 --exclude=PATTERN 排除与PATTERN 中描述的模式相符的文件 --max-depth=N 显示目录总计(与--all 一起使用计算文件) 当N 为指定数值时计算深度为N； --max-depth=0 等于--summarize --time 显示目录或该目录子目录下所有文件的最后修改时间 --time=WORD 显示WORD 时间，而非修改时间： atime，access，use，ctime 或status --time-style=样式 按照指定样式显示时间(样式解释规则同&quot;date&quot;命令)： full-iso，long-iso，iso，+FORMAT --help 显示此帮助信息并退出 --version 显示版本信息并退出 [大小]可以是以下的单位(单位前可加上整数)： kB 1000，K 1024，MB 1000000，M 1048576，还有 G、T、P、E、Z、Y。请向报告du 的错误 GNU coreutils 项目主页：&lt;http://www.gnu.org/software/coreutils/&gt; GNU 软件一般性帮助：&lt;http://www.gnu.org/gethelp/&gt; 请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告du 的翻译错误 示例：du –max-depth=1 -h1234root@raspberrypi:/home# du --max-depth=1 -h47M ./git241M ./pi288M .]]></content>
      <categories>
        <category>服务器</category>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp开机自启]]></title>
    <url>%2F2018%2F04%2F15%2Ffrp%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%2F</url>
    <content type="text"><![CDATA[vi /etc/systemd/system/frps.service 服务端1234567891011[Unit]Description=frps daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/root/frp_0.13.0_linux_amd64/frps -c /root/frp_0.13.0_linux_amd64/frps_my.iniRestart= alwaysRestartSec=1min[Install]WantedBy=multi-user.target client端1234567891011[Unit]Description=frpc daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/root/frp_0.13.0_linux_amd64/frpc -c /root/frp_0.13.0_linux_amd64/frpc_my.iniRestart= alwaysRestartSec=1min[Install]WantedBy=multi-user.target systemctl start frpc //启动systemctl status frpc //状态查询systemctl enable frpc //开机启动]]></content>
      <categories>
        <category>网络</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>linux</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04下编译openJDK7]]></title>
    <url>%2F2018%2F04%2F15%2Flinux-2018-04-15-Ubuntu16-04%E4%B8%8B%E7%BC%96%E8%AF%91openJDK7%2F</url>
    <content type="text"><![CDATA[本来是看 《深入理解Java虚拟机》第二版的，里面的第一章就是编译openJDK7，所以兴致勃勃的在我的mac系统上编译，不过有好多问题😂，所有装了个虚拟机使用了Ubuntu编译了openJDk7 ，原因是资料多。下面就开始一一列出经过和遇到的坑及解决办法吧！ 首先，当然是下载openJdk7源码了使用 Mercurial,因为openJdk7 是使用这个版本控制管理的 1sudo apt-get install mercurial 接下来就是下载源码了 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh./get_source.sh 给你建议，如果有云服务器，建议在上面下载完，在导入本地，我的本地网络下载不了，原因大家都懂😭 编译的过程大部分是摘抄 1sudo apt-get install build-essential gawk m4 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant jdk-6u45-linux-x64.bin,资源自己搜，安装在本机。 libmotif3也不能直接安装，下载地址 环境变量设置 enviroment.sh ,make sanity检查使用方法：将这个文件，放到你下载好的源码根目录下，有make文件的那个文件夹，我在这转了好几圈，1、编译前要用 source environment.sh 是这个文件生效2、使用 make sanity如果输出是Sanity check passed，则证明检查通过，可以进行make了 123456789101112131415161718192021222324252627#!/bin/sh# environment.shexport LANG=Cexport ALT_BOOTDIR=/usr/lib/java/jdk1.6.0_45export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=4export ALT_PARALLEL_COMPILE_JOBS=4export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=true#export BUILD_JAXP=false#export BUILD_JAXWS=false#export BUILD_CORBA=falseexport BUILD_HOTSPORT=trueexport BUILD_JDK=true# export SKIP_DEBUG_BUILD=false# export SKIP_FASTDEBUG_BUILD=true# export DEBUG_NAME=debugBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/mk/jdk7buildunset JAVA_HOMEunset CLASSPATHunset LD_LIBRARY_PATH 编译了 输入make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log进行编译 若出现以下信息，则证明编译成功 123456789101112131415161718############################################################################# Leaving jdk for target(s) sanity all docs images ################################################################################## Build time 00:04:29 jdk for target(s) sanity all docs images #############################################################################-- Build times ----------Target all_product_buildStart 2018-04-15 11:23:03End 2018-04-15 11:27:4300:00:03 corba00:00:03 hotspot00:00:02 jaxp00:00:02 jaxws00:04:29 jdk00:00:01 langtools00:04:40 TOTAL------------------------- 错误解决办法问题一123456789101112131415161718192021222324/usr/include/x86_64-linux-gnu/sys/cdefs.h:42:0: note: this is the location of the previous definition # define __LEAF , __leaf__ ^cc1plus: all warnings being treated as errors/home/mk/jdk7up/jdk7/hotspot/make/linux/makefiles/vm.make:260: recipe for target &apos;precompiled.hpp.gch&apos; failedmake[6]: *** [precompiled.hpp.gch] Error 1make[6]: Leaving directory &apos;/home/mk/jdk7build/hotspot/outputdir/linux_amd64_compiler2/product&apos;/home/mk/jdk7up/jdk7/hotspot/make/linux/makefiles/top.make:117: recipe for target &apos;the_vm&apos; failedmake[5]: *** [the_vm] Error 2make[5]: Leaving directory &apos;/home/mk/jdk7build/hotspot/outputdir/linux_amd64_compiler2/product&apos;/home/mk/jdk7up/jdk7/hotspot/make/linux/Makefile:289: recipe for target &apos;product&apos; failedmake[4]: *** [product] Error 2make[4]: Leaving directory &apos;/home/mk/jdk7build/hotspot/outputdir&apos;Makefile:180: recipe for target &apos;generic_build2&apos; failedmake[3]: *** [generic_build2] Error 2make[3]: Leaving directory &apos;/home/mk/jdk7up/jdk7/hotspot/make&apos;Makefile:138: recipe for target &apos;product&apos; failedmake[2]: *** [product] Error 2make[2]: Leaving directory &apos;/home/mk/jdk7up/jdk7/hotspot/make&apos;make/hotspot-rules.gmk:97: recipe for target &apos;hotspot-build&apos; failedmake[1]: *** [hotspot-build] Error 2make[1]: Leaving directory &apos;/home/mk/jdk7up/jdk7&apos;Makefile:244: recipe for target &apos;build_product_image&apos; failedmake: *** [build_product_image] Error 2 解决办法： 123456789在interfaceSupport.hpp增加#ifdef __LEAF#undef __LEAF#define __LEAF(result_type, header) \ TRACE_CALL(result_type, header) \ debug_only(NoHandleMark __hm;) \ /* begin of body */#endif 问题二12345678910111213141516171819/usr/lib/java/jdk1.6.0_45/bin/idlj -J-XX:-PrintVMOptions -J-XX:+UnlockDiagnosticVMOptions -J-XX:-LogVMOutput -J-Xmx512m -J-Xms512m -J-XX:PermSize=32m -J-XX:MaxPermSize=160m -td &quot;/home/mk/jdk7build/corba/gensrc&quot; -i &quot;../../../../src/share/classes/org/omg/PortableServer&quot; -i &quot;../../../../src/share/classes/org/omg/PortableInterceptor&quot; -corba 3.0 -fall -pkgPrefix PortableServer org.omg ../../../../src/share/classes/org/omg/PortableServer/poa.idlError occurred during initialization of VMCould not reserve enough space for object heapMakefile:96: recipe for target &apos;/home/mk/jdk7build/corba/gensrc/org/omg/PortableServer/CurrentHelper.java&apos; failedmake[5]: *** [/home/mk/jdk7build/corba/gensrc/org/omg/PortableServer/CurrentHelper.java] Error 1make[5]: Leaving directory &apos;/home/mk/jdk7up/jdk7/corba/make/org/omg/sources&apos;Makefile:42: recipe for target &apos;build&apos; failedmake[4]: *** [build] Error 1make[4]: Leaving directory &apos;/home/mk/jdk7up/jdk7/corba/make/org/omg&apos;Makefile:41: recipe for target &apos;build&apos; failedmake[3]: *** [build] Error 1make[3]: Leaving directory &apos;/home/mk/jdk7up/jdk7/corba/make/org&apos;Makefile:166: recipe for target &apos;build&apos; failedmake[2]: *** [build] Error 1make[2]: Leaving directory &apos;/home/mk/jdk7up/jdk7/corba/make&apos;make/corba-rules.gmk:42: recipe for target &apos;corba-build&apos; failedmake[1]: *** [corba-build] Error 2make[1]: Leaving directory &apos;/home/mk/jdk7up/jdk7&apos;Makefile:244: recipe for target &apos;build_product_image&apos; failed 解决办法： 文件中有空格 问题三123456(cd ./langtools/make &amp;&amp; \ make JDK_TOPDIR=/home/mk/jdk7up/jdk7/jdk JDK_MAKE_SHARED_DIR=/home/mk/jdk7up/jdk7/jdk/make/common/shared EXTERNALSANITYCONTROL=true SOURCE_LANGUAGE_VERSION=7 TARGET_CLASS_VERSION=7 MILESTONE=internal BUILD_NUMBER=b00 JDK_BUILD_NUMBER=b00 FULL_VERSION=1.7.0-internal-mk_2018_04_13_16_15-b00 PREVIOUS_JDK_VERSION=1.6.0 JDK_VERSION=1.7.0 JDK_MKTG_VERSION=7 JDK_MAJOR_VERSION=1 JDK_MINOR_VERSION=7 JDK_MICRO_VERSION=0 PREVIOUS_MAJOR_VERSION=1 PREVIOUS_MINOR_VERSION=6 PREVIOUS_MICRO_VERSION=0 ARCH_DATA_MODEL=64 COOKED_BUILD_NUMBER=0 ALT_OUTPUTDIR=/home/mk/jdk7up/jdk7/build/linux-amd64/langtools ALT_BOOTDIR=/NO_BOOTDIR all)make[2]: Entering directory &apos;/home/mk/jdk7up/jdk7/langtools/make&apos;JAVA_HOME=/NO_BOOTDIR ANT_OPTS=-Djava.io.tmpdir=&apos;/home/mk/jdk7up/jdk7/build/linux-amd64/langtools/build/ant-tmp&apos; ant -Djdk.version=1.7.0 -Dfull.version=&apos;1.7.0-internal-mk_2018_04_13_16_15-b00&apos; -Dmilestone=internal -Dbuild.number=b00 -Djavac.target=7 -Djavac.source=7 -Dboot.java.home=/NO_BOOTDIR -Dimport.jdk=/home/mk/jdk7up/jdk7/jdk -Dbuild.dir=/home/mk/jdk7up/jdk7/build/linux-amd64/langtools/build -Ddist.dir=/home/mk/jdk7up/jdk7/build/linux-amd64/langtools/dist buildError: JAVA_HOME is not defined correctly. We cannot execute /NO_BOOTDIR/bin/java 解决办法： 环境变量没有设置，也就是，environment.sh 没有执行 source environment.sh 问题四12g++ -DLINUX -D_GNU_SOURCE -DAMD64 -DPRODUCT -I. -I/home/mk/jdk7up/jdk7/hotspot/src/share/vm/prims -I/home/mk/jdk7up/jdk7/hotspot/src/share/vm -I/home/mk/jdk7up/jdk7/hotspot/src/cpu/x86/vm -I/home/mk/jdk7up/jdk7/hotspot/src/os_cpu/linux_x86/vm -I/home/mk/jdk7up/jdk7/hotspot/src/os/linux/vm -I/home/mk/jdk7up/jdk7/hotspot/src/os/posix/vm -I../generated -DHOTSPOT_RELEASE_VERSION=&quot;\&quot;21.0-b17\&quot;&quot; -DHOTSPOT_BUILD_TARGET=&quot;\&quot;product\&quot;&quot; -DHOTSPOT_BUILD_USER=&quot;\&quot;mk\&quot;&quot; -DHOTSPOT_LIB_ARCH=\&quot;amd64\&quot; -DJRE_RELEASE_VERSION=&quot;\&quot;1.7.0-internal-mk_2018_04_13_16_21-b00\&quot;&quot; -DHOTSPOT_VM_DISTRO=&quot;\&quot;OpenJDK\&quot;&quot; -DTARGET_OS_FAMILY_linux -DTARGET_ARCH_x86 -DTARGET_ARCH_MODEL_x86_64 -DTARGET_OS_ARCH_linux_x86 -DTARGET_OS_ARCH_MODEL_linux_x86_64 -DTARGET_COMPILER_gcc -DCOMPILER2 -DCOMPILER1 -fPIC -fno-rtti -fno-exceptions -D_REENTRANT -fcheck-new -fvisibility=hidden -m64 -pipe -O3 -fno-strict-aliasing -DVM_LITTLE_ENDIAN -D_LP64=1 -fno-omit-frame-pointer -Werror -Wpointer-arith -Wsign-compare -c -MMD -MP -MF ../generated/dependencies/dump_x86_64.o.d -o dump_x86_64.o /home/mk/jdk7up/jdk7/hotspot/src/cpu/x86/vm/dump_x86_64.cppcc1plus: all warnings being treated as errors 解决办法： 12在hotspot/make/makefiles/gcc.make 中，把 -Werror 选项去掉。/home/mk/jdk7up/jdk7/hotspot/make/linux/makefiles/gcc.make 问题五123-ljvm -lcgcc: error: unrecognized command line option &apos;-mimpure-text&apos;../../common/Library.gmk:221: recipe for target &apos;/home/mk/jdk7build/lib/amd64/libverify.so&apos; failed 解决办法： 1234/home/mk/jdk7up/jdk7/jdk/make/common/shared/Compiler-gcc.gmk 在文件里的第70行 #SHARED_LIBRARY_FLAG = -shared -mimpure-text 改为 SHARED_LIBRARY_FLAG = -shared 问题六12345Error: time is more than 10 years from present: 1136059200000java.lang.RuntimeException: time is more than 10 years from present: 1136059200000 at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:285) at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:225) at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:154) 解决办法 1234567891011# 修改CurrencyData.properties（路径：jdk/src/share/classes/java/util/CurrencyData.properties）修改108行AZ=AZM;2009-12-31-20-00-00;AZN修改381行MZ=MZM;2009-06-30-22-00-00;MZN修改443行RO=ROL;2009-06-30-21-00-00;RON修改535行TR=TRL;2009-12-31-22-00-00;TRY修改561行VE=VEB;2009-01-01-04-00-00;VEF 问题七1make[5]: *** [/home/lichengwu/openjdk7/build/linux-amd64/lib/amd64/libjsoundalsa.so] Error 1 解决办法： 12ln -s build/linux-amd64/lib/amd64/libjsound.so build/linux-amd64/lib/amd64/libjsoundalsa.soln 命令解决不了，使用 cp命令]]></content>
      <categories>
        <category>编程语言</category>
        <category>java编译</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>openJDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器DMZ原理]]></title>
    <url>%2F2018%2F04%2F12%2Flinux-2018-04-12-%E8%B7%AF%E7%94%B1%E5%99%A8DMZ%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[搞了一个树莓派，想直接外网可以访问所以就遇到这个东东 来个概念简介吧 维基百科 123DMZ，全写Demilitarized Zone，译名为“非军事区”[1]，又名Perimeter network，即“边界网络”、周边网络[2]或“对外网络”，为一种网络架构的布置方案，常用的架设方案是在不信任的外部网络和可信任的内部网络外，创建一个面向外部网络的物理或逻辑子网，该子网能设置用于对外部网络的服务器主机。该方案可以使用在防火墙、路由器等区隔内外网的网络设备。在一般比较低级的网络设备，DMZ的功能只能以软件设置的接口去设置并实现，实体的网络层相接，会与一般的LAN PORT相接共同管理。不过在一般比较高阶的网络设备，如高阶的防火墙设备，DMZ的功能除了软件的接口的设置外，在实体的连接PORT除了一般的WAN PORT、LAN PORT外，还会有另外独立的DMZ PORT，这样可以方便网络管理人员在管理网段时，除了软件接口上去设置WAN、LAN、DMZ等网段外，在实体的缆线连接（通常采用的是RJ45）时，也可以直接区分网段，更方便管理。 一般网络分成内网和外网，也就是LAN和WAN,那么，当你有1台物理位置上的1台服务器，需要被外网访问，并且，也被内网访问的时候，那么，有2种方法，一种是放在LAN中，一种是放在DMZ。因为防火墙默认情况下，是为了保护内网的，所以，一般的策略是禁止外网访问内网，许可内网访问外网。但如果这个服务器能被外网所访问，那么，就意味着这个服务器已经处于不可信任的状态，那么，这个服务器就不能（主动）访问内网。所以，如果服务器放在内网（通过端口重定向让外网访问），一旦这个服务器被攻击，则内网将会处于非常不安全的状态。但DMZ就是为了让外网能访问内部的资源，（内部资源在这里指的就是这个服务器），而内网呢，也能访问这个服务器，但这个服务器是不能主动访问内网的。DMZ就是这样的一个区域。为了让物理位置在内网的，并且，希望能被外网所访问的这样的一个区域。 一个典型的DMZ区的应用图，用户将Web、Mail、FTP等需要为内部和外部网络提供服务的服务器放置到防火墙的DMZ区内。通过合理的策略规划，使DMZ中服务器既免受到来自外网络的入侵和破坏，也不会对内网中的机密信息造成影响。DMZ服务区好比一道屏障，在其中放置外网服务器，在为外网用户提供服务的同时也有效地保障了内部网络的安全。 DMZ应用在一个用路由器连接的局域网中,我们可以将网络划分为三个区域：安全级别最高的LAN Area（内网）,安全级别中等的DMZ区域和安全级别最低的Internet区域（外网）。三个区域因担负不同的任务而拥有不同的访问策略。我们在配置一个拥有DMZ区的网络的时候通常定义以下的访问控制策略以实现DMZ区的屏障功能。1、内网可以访问外网内网的用户需要自由地访问外网。在这一策略中，防火墙需要执行NAT。 2、内网可以访问DMZ此策略使内网用户可以使用或者管理DMZ中的服务器。 3、外网不能访问内网这是防火墙的基本策略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如果要访问，就要通过VPN方式来进行。 4、外网可以访问DMZDMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。 5、DMZ不能访问内网如不执行此策略，则当入侵者攻陷DMZ时，内部网络将不会受保护。 6、DMZ不能访问外网此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。 在没有DMZ的技术之前，需要使用外网服务器的用户必须在其防火墙上面开放端口（就是Port Forwarding技术）使互联网的用户访问其外网服务器，显然，这种做法会因为防火墙对互联网开放了一些必要的端口降低了需要受严密保护的内网区域的安全性，黑客们只需要攻陷外网服务器，那么整个内部网络就完全崩溃了。DMZ区的诞生恰恰为需用架设外网服务器的用户解决了内部网络的安全性问题。 原贴地址]]></content>
      <categories>
        <category>服务器</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>DMZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gogs后台运行及重启]]></title>
    <url>%2F2018%2F04%2F12%2Flinux-2018-04-12-gogs%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%8F%8A%E9%87%8D%E5%90%AF%2F</url>
    <content type="text"><![CDATA[gogs 运行在后台后出现问题不会关😭 1$ nohup ./gogs web &amp; 后台运行后可以使用 123$ lsof -i:3000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEgogs 17483 git 6u IPv6 338433 0t0 TCP *:3000 (LISTEN) 然后就可以使用杀掉进程了，最后就是你放心的启动gogs吧😁 1$ kill -9 17483]]></content>
      <categories>
        <category>服务器</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有云Owncloud搭建]]></title>
    <url>%2F2018%2F04%2F06%2Flinux-2018-04-06-%E7%A7%81%E6%9C%89%E4%BA%91Owncloud%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[owncloudOwnCloud是一个基于Linux系统的开源云项目，允许用户建立自己的个人云服务器，目前功能包括文件分享、音乐存储、日历、联系人和书签共享等等。OwnCloud业务人员称，“相比Dropbox和box.net，我们提供的服务更实惠，更安全，更方便管理，灵活性更强，十分适合商业用途。OwnCloud用户还可在自己的硬件和存储设备上实现文件同步和共享服务。 Owncould下载网址 本次搭建采用了 nginx+owncloud+php5 一、根据上面的网址下载 ownCould 安装包解压开压缩包，并且将解压后的文件移动到对应的文件夹 想要存放 website的目录 /data/website/owncloud 12tar -jxvf owncloud-10.0.7.tar.bz2mv owncloud /data/website/owncloud 上面目录owncloud 需要配置权限 1drwxr-x--- 14 root www-data 4096 4月 6 21:45 owncloud 官方摘的权限配置 需要修改You can find your HTTP user in your HTTP server configuration files. Or you can use PHP Version and Information (Look for the User/Group line). 1234The HTTP user and group in Debian/Ubuntu is www-data.The HTTP user and group in Fedora/CentOS is apache.The HTTP user and group in Arch Linux is http.The HTTP user in openSUSE is wwwrun, and the HTTP group is www. 可以使用 下面的命令 检查 用户是否有访问，你设置磁盘路径的权限 1sudo -u www-data ls -la /media/pi/pi-data/owncloud 二、配置nginx 代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859upstream php-handler &#123; server 127.0.0.1:9000; #server unix:/var/run/php5-fpm.sock;&#125;server &#123; listen 81; server_name www.test.com; # Path to the root of your installation root /data/website/owncloud; index index.html index.htm index.php; # set max upload size client_max_body_size 10G; fastcgi_buffers 64 4K; # Disable gzip to avoid the removal of the ETag header gzip off; # Uncomment if your server is build with the ngx_pagespeed module # This module is currently not supported. #pagespeed off; rewrite ^/caldav(.*)$ /remote.php/caldav$1 redirect; rewrite ^/carddav(.*)$ /remote.php/carddav$1 redirect; rewrite ^/webdav(.*)$ /remote.php/webdav$1 redirect; index index.php; error_page 403 /core/templates/403.php; error_page 404 /core/templates/404.php; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; location ~ ^/(?:\.htaccess|data|config|db_structure\.xml|README)&#123; deny all; &#125; location / &#123; # The following 2 rules are only needed with webfinger rewrite ^/.well-known/host-meta /public.php?service=host-meta last; rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json last; rewrite ^/.well-known/carddav /remote.php/carddav/ redirect; rewrite ^/.well-known/caldav /remote.php/caldav/ redirect; rewrite ^(/core/doc/[^\/]+/)$ $1/index.html;&quot;owncould.conf&quot; 56L, 2123C 1,1 顶端 rewrite ^/.well-known/caldav /remote.php/caldav/ redirect; rewrite ^(/core/doc/[^\/]+/)$ $1/index.html; try_files $uri $uri/ /index.php; &#125; location ~ \.php(?:$|/) &#123; fastcgi_split_path_info ^(.+\.php)(/.+)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php-handler; &#125; # Optional: set long EXPIRES header on static assets location ~* \.(?:jpg|jpeg|gif|bmp|ico|png|css|js|swf)$ &#123; expires 30d; # Optional: Don&apos;t log access to assets access_log off; &#125;&#125; 三、剩下的就是配置PHP 环境了Required PHP Version PHP &gt;= 5.6 (ideally 7.0 or above) 搭配需要的PHP环境 推荐 7.0 1234apt-get install -y libsmbclient-dev libssh2-1-dev openssl php5-imagick \ php5-common php5-curl php5-dev php5-gd \ php5-imap php5-intl php5-json php5-ldap \ php5-mcrypt php5-mysql php5-pgsql php5-sqlite 提示：如果获取不到php 环境变量修改目录 /etc/php5/fpm/pool.d/www.conf 12345678; Pass environment variables like LD_LIBRARY_PATH. All $VARIABLEs are taken from; the current environment.; Default Value: clean envenv[HOSTNAME] = $HOSTNAMEenv[PATH] = /usr/local/bin:/usr/bin:/binenv[TMP] = /tmpenv[TMPDIR] = /tmpenv[TEMP] = /tmp 放一张正常启动的图]]></content>
      <categories>
        <category>服务器</category>
        <category>文件服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>私有云</tag>
        <tag>文件服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派frp搭建内网穿透]]></title>
    <url>%2F2018%2F04%2F06%2Flinux-2018-04-06-%E6%A0%91%E8%8E%93%E6%B4%BEfrp%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[frpfrp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 目录 frp 的作用 开发状态 架构 使用示例 通过 ssh 访问公司内网机器 通过自定义域名访问部署于内网的 web 服务 转发 DNS 查询请求 转发 Unix域套接字 对外提供简单的文件访问服务 安全地暴露内网服务 点对点内网穿透 通过 frpc 所在机器访问外网 功能说明 配置文件 Dashboard 身份验证 加密与压缩 客户端热加载配置文件 客户端查看代理状态 特权模式 端口白名单 TCP 多路复用 底层通信可选 kcp 协议 连接池 修改 Host Header 获取用户真实 IP 通过密码保护你的 web 服务 自定义二级域名 URL 路由 通过代理连接 frps 范围端口映射 插件 开发计划 为 frp 做贡献 捐助 支付宝扫码捐赠 微信支付捐赠 Paypal 捐赠 frp 的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 开发状态frp 仍然处于前期开发阶段，未经充分测试与验证，不推荐用于生产环境。 master 分支用于发布稳定版本，dev 分支用于开发，您可以尝试下载最新的 release 版本进行测试。 目前的交互协议可能随时改变，不保证向后兼容，升级新版本时需要注意公告说明同时升级服务端和客户端。 架构 使用示例根据对应的操作系统及架构，从 Release 页面下载最新版本的程序。 将 frps 及 frps.ini 放到具有公网 IP 的机器上。 将 frpc 及 frpc.ini 放到处于内网环境的机器上。 通过 ssh 访问公司内网机器 修改 frps.ini 文件，这里使用了最简化的配置： 123# frps.ini[common]bind_port = 7000 启动 frps： ./frps -c ./frps.ini 修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x； 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 启动 frpc： ./frpc -c ./frpc.ini 通过 ssh 访问内网机器，假设用户名为 test： ssh -oPort=6000 test@x.x.x.x 通过自定义域名访问部署于内网的 web 服务有时想要让其他人通过域名访问或者测试我们在本地搭建的 web 服务，但是由于本地机器没有公网 IP，无法将域名解析到本地的机器，通过 frp 就可以实现这一功能，以下示例为 http 服务，https 服务配置方法相同， vhost_http_port 替换为 vhost_https_port， type 设置为 https 即可。 修改 frps.ini 文件，设置 http 访问端口为 8080： 1234# frps.ini[common]bind_port = 7000vhost_http_port = 8080 启动 frps； ./frps -c ./frps.ini 修改 frpc.ini 文件，假设 frps 所在的服务器的 IP 为 x.x.x.x，local_port 为本地机器上 web 服务对应的端口, 绑定自定义域名 www.yourdomain.com: 123456789# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[web]type = httplocal_port = 80custom_domains = www.yourdomain.com 启动 frpc： ./frpc -c ./frpc.ini 将 www.yourdomain.com 的域名 A 记录解析到 IP x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。 通过浏览器访问 http://www.yourdomain.com:8080 即可访问到处于内网机器上的 web 服务。 转发 DNS 查询请求DNS 查询请求通常使用 UDP 协议，frp 支持对内网 UDP 服务的穿透，配置方式和 TCP 基本一致。 修改 frps.ini 文件： 123# frps.ini[common]bind_port = 7000 启动 frps： ./frps -c ./frps.ini 修改 frpc.ini 文件，设置 frps 所在服务器的 IP 为 x.x.x.x，转发到 Google 的 DNS 查询服务器 8.8.8.8 的 udp 53 端口： 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[dns]type = udplocal_ip = 8.8.8.8local_port = 53remote_port = 6000 启动 frpc： ./frpc -c ./frpc.ini 通过 dig 测试 UDP 包转发是否成功，预期会返回 www.google.com 域名的解析结果： dig @x.x.x.x -p 6000 www.google.com 转发 Unix域套接字通过 tcp 端口访问内网的 unix域套接字(例如和 docker daemon 通信)。 frps 的部署步骤同上。 启动 frpc，启用 unix_domain_socket 插件，配置如下： 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[unix_domain_socket]type = tcpremote_port = 6000plugin = unix_domain_socketplugin_unix_path = /var/run/docker.sock 通过 curl 命令查看 docker 版本信息 curl http://x.x.x.x:6000/version 对外提供简单的文件访问服务通过 static_file 插件可以对外提供一个简单的基于 HTTP 的文件访问服务。 frps 的部署步骤同上。 启动 frpc，启用 static_file 插件，配置如下： 123456789101112131415# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[test_static_file]type = tcpremote_port = 6000plugin = static_file# 要对外暴露的文件目录plugin_local_path = /tmp/file# 访问 url 中会被去除的前缀，保留的内容即为要访问的文件路径plugin_strip_prefix = staticplugin_http_user = abcplugin_http_passwd = abc 通过浏览器访问 http://x.x.x.x:6000/static/ 来查看位于 /tmp/file 目录下的文件，会要求输入已设置好的用户名和密码。 安全地暴露内网服务对于某些服务来说如果直接暴露于公网上将会存在安全隐患。 使用 stcp(secret tcp) 类型的代理可以避免让任何人都能访问到要穿透的服务，但是访问者也需要运行另外一个 frpc。 以下示例将会创建一个只有自己能访问到的 ssh 服务代理。 frps 的部署步骤同上。 启动 frpc，转发内网的 ssh 服务，配置如下，不需要指定远程端口： 1234567891011# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[secret_ssh]type = stcp# 只有 sk 一致的用户才能访问到此服务sk = abcdefglocal_ip = 127.0.0.1local_port = 22 在要访问这个服务的机器上启动另外一个 frpc，配置如下： 123456789101112131415# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[secret_ssh_visitor]type = stcp# stcp 的访问者role = visitor# 要访问的 stcp 代理的名字server_name = secret_sshsk = abcdefg# 绑定本地端口用于访问 ssh 服务bind_addr = 127.0.0.1bind_port = 6000 通过 ssh 访问内网机器，假设用户名为 test： ssh -oPort=6000 test@127.0.0.1 点对点内网穿透frp 提供了一种新的代理类型 xtcp 用于应对在希望传输大量数据且流量不经过服务器的场景。 使用方式同 stcp 类似，需要在两边都部署上 frpc 用于建立直接的连接。 目前处于开发的初级阶段，并不能穿透所有类型的 NAT 设备，所以穿透成功率较低。穿透失败时可以尝试 stcp 的方式。 frps 除正常配置外需要额外配置一个 udp 端口用于支持该类型的客户端: 1bind_udp_port = 7001 启动 frpc，转发内网的 ssh 服务，配置如下，不需要指定远程端口: 1234567891011# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[p2p_ssh]type = xtcp# 只有 sk 一致的用户才能访问到此服务sk = abcdefglocal_ip = 127.0.0.1local_port = 22 在要访问这个服务的机器上启动另外一个 frpc，配置如下: 123456789101112131415# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[p2p_ssh_visitor]type = xtcp# xtcp 的访问者role = visitor# 要访问的 xtcp 代理的名字server_name = p2p_sshsk = abcdefg# 绑定本地端口用于访问 ssh 服务bind_addr = 127.0.0.1bind_port = 6000 通过 ssh 访问内网机器，假设用户名为 test: ssh -oPort=6000 test@127.0.0.1 通过 frpc 所在机器访问外网frpc 内置了 http proxy 和 socks5 插件，可以使其他机器通过 frpc 的网络访问互联网。 frps 的部署步骤同上。 启动 frpc，启用 http_proxy 或 socks5 插件(plugin 换为 socks5 即可)， 配置如下： 123456789# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[http_proxy]type = tcpremote_port = 6000plugin = http_proxy 浏览器设置 http 或 socks5 代理地址为 x.x.x.x:6000，通过 frpc 机器的网络访问互联网。 功能说明配置文件由于 frp 目前支持的功能和配置项较多，未在文档中列出的功能可以从完整的示例配置文件中发现。 frps 完整配置文件 frpc 完整配置文件 Dashboard通过浏览器查看 frp 的状态以及代理统计信息展示。 需要在 frps.ini 中指定 dashboard 服务使用的端口，即可开启此功能： 12345[common]dashboard_port = 7500# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin 打开浏览器通过 http://[server_addr]:7500 访问 dashboard 界面，用户名密码默认为 admin。 身份验证从 v0.10.0 版本开始，所有 proxy 配置全部放在客户端(也就是之前版本的特权模式)，服务端和客户端的 common 配置中的 privilege_token 参数一致则身份验证通过。 需要注意的是 frpc 所在机器和 frps 所在机器的时间相差不能超过 15 分钟，因为时间戳会被用于加密验证中，防止报文被劫持后被其他人利用。 这个超时时间可以在配置文件中通过 authentication_timeout 这个参数来修改，单位为秒，默认值为 900，即 15 分钟。如果修改为 0，则 frps 将不对身份验证报文的时间戳进行超时校验。 加密与压缩这两个功能默认是不开启的，需要在 frpc.ini 中通过配置来为指定的代理启用加密与压缩的功能，压缩算法使用 snappy： 1234567# frpc.ini[ssh]type = tcplocal_port = 22remote_port = 6000use_encryption = trueuse_compression = true 如果公司内网防火墙对外网访问进行了流量识别与屏蔽，例如禁止了 ssh 协议等，通过设置 use_encryption = true，将 frpc 与 frps 之间的通信内容加密传输，将会有效防止流量被拦截。 如果传输的报文长度较长，通过设置 use_compression = true 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源。 客户端热加载配置文件当修改了 frpc 中的代理配置，可以通过 frpc reload 命令来动态加载配置文件，通常会在 10 秒内完成代理的更新。 启用此功能需要在 frpc 中启用 admin 端口，用于提供 API 服务。配置如下： 1234# frpc.ini[common]admin_addr = 127.0.0.1admin_port = 7400 之后执行重启命令： frpc reload -c ./frpc.ini 等待一段时间后客户端会根据新的配置文件创建、更新、删除代理。 需要注意的是，[common] 中的参数除了 start 外目前无法被修改。 客户端查看代理状态frpc 支持通过 frpc status -c ./frpc.ini 命令查看代理的状态信息，此功能需要在 frpc 中配置 admin 端口。 特权模式由于从 v0.10.0 版本开始，所有 proxy 都在客户端配置，原先的特权模式是目前唯一支持的模式。 端口白名单为了防止端口被滥用，可以手动指定允许哪些端口被使用，在 frps.ini 中通过 privilege_allow_ports 来指定： 123# frps.ini[common]privilege_allow_ports = 2000-3000,3001,3003,4000-50000 privilege_allow_ports 可以配置允许使用的某个指定端口或者是一个范围内的所有端口，以 , 分隔，指定的范围以 - 分隔。 TCP 多路复用从 v0.10.0 版本开始，客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 frp 可以承载更高的并发数。 该功能默认启用，如需关闭，可以在 frps.ini 和 frpc.ini 中配置，该配置项在服务端和客户端必须一致： 123# frps.ini 和 frpc.ini 中[common]tcp_mux = false 底层通信可选 kcp 协议从 v0.12.0 版本开始，底层通信协议支持选择 kcp 协议，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。 开启 kcp 协议支持： 在 frps.ini 中启用 kcp 协议支持，指定一个 udp 端口用于接收客户端请求： 12345# frps.ini[common]bind_port = 7000# kcp 绑定的是 udp 端口，可以和 bind_port 一样kcp_bind_port = 7000 在 frpc.ini 指定需要使用的协议类型，目前只支持 tcp 和 kcp。其他代理配置不需要变更： 123456# frpc.ini[common]server_addr = x.x.x.x# server_port 指定为 frps 的 kcp_bind_portserver_port = 7000protocol = kcp 像之前一样使用 frp，需要注意开放相关机器上的 udp 的端口的访问权限。 连接池默认情况下，当用户请求建立连接后，frps 才会请求 frpc 主动与后端服务建立一个连接。当为指定的代理启用连接池后，frp 会预先和后端服务建立起指定数量的连接，每次接收到用户请求后，会从连接池中取出一个连接和用户连接关联起来，避免了等待与后端服务建立连接以及 frpc 和 frps 之间传递控制信息的时间。 这一功能比较适合有大量短连接请求时开启。 首先可以在 frps.ini 中设置每个代理可以创建的连接池上限，避免大量资源占用，客户端设置超过此配置后会被调整到当前值： 123# frps.ini[common]max_pool_count = 5 在 frpc.ini 中为客户端启用连接池，指定预创建连接的数量： 123# frpc.ini[common]pool_count = 1 修改 Host Header通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 http 请求 header 中的 host 字段来展现不同的网站，例如 nginx 的虚拟主机服务，启用 host-header 的修改功能可以动态修改 http 请求中的 host 字段。该功能仅限于 http 类型的代理。 123456# frpc.ini[web]type = httplocal_port = 80custom_domains = test.yourdomain.comhost_header_rewrite = dev.yourdomain.com 原来 http 请求中的 host 字段 test.yourdomain.com 转发到后端服务时会被替换为 dev.yourdomain.com。 获取用户真实 IP目前只有 http 类型的代理支持这一功能，可以通过用户请求的 header 中的 X-Forwarded-For 和 X-Real-IP 来获取用户真实 IP。 需要注意的是，目前只在每一个用户连接的第一个 HTTP 请求中添加了这两个 header。 通过密码保护你的 web 服务由于所有客户端共用一个 frps 的 http 服务端口，任何知道你的域名和 url 的人都能访问到你部署在内网的 web 服务，但是在某些场景下需要确保只有限定的用户才能访问。 frp 支持通过 HTTP Basic Auth 来保护你的 web 服务，使用户需要通过用户名和密码才能访问到你的服务。 该功能目前仅限于 http 类型的代理，需要在 frpc 的代理配置中添加用户名和密码的设置。 1234567# frpc.ini[web]type = httplocal_port = 80custom_domains = test.yourdomain.comhttp_user = abchttp_pwd = abc 通过浏览器访问 http://test.yourdomain.com，需要输入配置的用户名和密码才能访问。 自定义二级域名在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。 通过在 frps 的配置文件中配置 subdomain_host，就可以启用该特性。之后在 frpc 的 http、https 类型的代理中可以不配置 custom_domains，而是配置一个 subdomain 参数。 只需要将 *.{subdomain_host} 解析到 frps 所在服务器。之后用户可以通过 subdomain 自行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomain_host} 来访问自己的 web 服务。 123# frps.ini[common]subdomain_host = frps.com 将泛域名 *.frps.com 解析到 frps 所在服务器的 IP 地址。 12345# frpc.ini[web]type = httplocal_port = 80subdomain = test frps 和 fprc 都启动成功后，通过 test.frps.com 就可以访问到内网的 web 服务。 需要注意的是如果 frps 配置了 subdomain_host，则 custom_domains 中不能是属于 subdomain_host 的子域名或者泛域名。 同一个 http 或 https 类型的代理中 custom_domains 和 subdomain 可以同时配置。 URL 路由frp 支持根据请求的 URL 路径路由转发到不同的后端服务。 通过配置文件中的 locations 字段指定一个或多个 proxy 能够匹配的 URL 前缀(目前仅支持最大前缀匹配，之后会考虑正则匹配)。例如指定 locations = /news，则所有 URL 以 /news 开头的请求都会被转发到这个服务。 123456789101112# frpc.ini[web01]type = httplocal_port = 80custom_domains = web.yourdomain.comlocations = /[web02]type = httplocal_port = 81custom_domains = web.yourdomain.comlocations = /news,/about 按照上述的示例配置后，web.yourdomain.com 这个域名下所有以 /news 以及 /about 作为前缀的 URL 请求都会被转发到 web02，其余的请求会被转发到 web01。 通过代理连接 frps在只能通过代理访问外网的环境内，frpc 支持通过 HTTP PROXY 和 frps 进行通信。 可以通过设置 HTTP_PROXY 系统环境变量或者通过在 frpc 的配置文件中设置 http_proxy 参数来使用此功能。 仅在 protocol = tcp 时生效。 12345# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000http_proxy = http://user:pwd@192.168.1.128:8080 范围端口映射在 frpc 的配置文件中可以指定映射多个端口，目前只支持 tcp 和 udp 的类型。 这一功能通过 range: 段落标记来实现，客户端会解析这个标记中的配置，将其拆分成多个 proxy，每一个 proxy 以数字为后缀命名。 例如要映射本地 6000-6005, 6007 这6个端口，主要配置如下： 123456# frpc.ini[range:test_tcp]type = tcplocal_ip = 127.0.0.1local_port = 6000-6006,6007remote_port = 6000-6006,6007 实际连接成功后会创建 6 个 proxy，命名为 test_tcp_0, test_tcp_1 ... test_tcp_5。 插件默认情况下，frpc 只会转发请求到本地 tcp 或 udp 端口。 插件模式是为了在客户端提供更加丰富的功能，目前内置的插件有 unix_domain_socket、http_proxy、socks5、static_file。具体使用方式请查看使用示例。 通过 plugin 指定需要使用的插件，插件的配置参数都以 plugin_ 开头。使用插件后 local_ip 和 local_port 不再需要配置。 使用 http_proxy 插件的示例: 1234567# frpc.ini[http_proxy]type = tcpremote_port = 6000plugin = http_proxyplugin_http_user = abcplugin_http_passwd = abc plugin_http_user 和 plugin_http_passwd 即为 http_proxy 插件可选的配置参数。]]></content>
      <categories>
        <category>网络</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解压命令大全]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z 解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName .lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName .rpm解包：rpm2cpio FileName.rpm | cpio -div .deb解包：ar p FileName.deb data.tar.gz | tar zxf]]></content>
      <categories>
        <category>服务器</category>
        <category>linux指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker下安装mongoDB]]></title>
    <url>%2F2018%2F04%2F03%2Fdocker%E4%B8%8B%E5%AE%89%E8%A3%85mongoDB%2F</url>
    <content type="text"><![CDATA[有一个node项目需要看用到mongo，所以搭建一个mongo 环境，由于电脑上有docker 所有优先使用了docker下安装 首先让我们到 DockerHub 上溜一圈去，看看]]></content>
      <categories>
        <category>服务器</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>mongo</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM之LiveData介绍]]></title>
    <url>%2F2018%2F02%2F26%2Fandroid-2018-02-26-MVVM%E4%B9%8BLiveData%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[LiveData原文网址 LiveData is an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware(生命周期), meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state. LiveData considers an observer, which is represented(代表) by the Observer class, to be in an active state if its lifecycle is in the STARTED or RESUMED state. LiveData only notifies active observers about updates. Inactive observers registered to watch LiveData objects aren’t notified about changes. You can register an observer paired with an object that implements the LifecycleOwner interface. This relationship allows the observer to be removed when the state of the corresponding Lifecycle object changes to DESTROYED. This is especially useful for activities and fragments because they can safely observe LiveData objects and not worry about leaks—activities and fragments are instantly unsubscribed when their lifecycles are destroyed. 翻译： 您可以注册与实现LifecycleOwner接口的对象配对的观察者。 此关系允许在相应Lifecycle对象的状态更改为DESTROYED时删除观察者。 这对于活动和片段特别有用，因为它们可以安全地观察LiveData对象而不用担心泄漏 - 活动和片段在其生命周期被破坏时立即取消订阅。 The advantages of using LiveDataUsing LiveData provides the following advantages: Ensures （确保）your UI matches your data stateLiveData follows the observer pattern. LiveData notifies Observer objects when the lifecycle state changes. You can consolidate your code to update the UI in these Observer objects. Instead of updating the UI every time the app data changes, your observer can update the UI every time there’s a change. LiveData遵循观察者模式。 生命周期状态更改时，LiveData会通知Observer对象。 您可以合并代码以更新这些Observer对象中的UI。 每次应用程序数据更改时，您的观察者都可以在每次更改时更新UI，而不是更新UI每时每刻。 No memory leaksObservers are bound to Lifecycle objects and clean up after themselves when their associated lifecycle is destroyed. No crashes due to stopped activitiesIf the observer’s lifecycle is inactive, such as in the case of an activity in the back stack, then it doesn’t receive any LiveData events. No more manual lifecycle handlingUI components just observe relevant（有关） data and don’t stop or resume observation. LiveData automatically manages all of this since it’s aware of the relevant lifecycle status changes while observing. UI组件只是观察相关（有关）数据，不会停止或恢复观察。 LiveData自动管理所有这些，因为它在观察时意识到相关的生命周期状态变化。 Always up to date dataIf a lifecycle becomes inactive(不活跃的), it receives the latest data upon becoming active again. For example, an activity that was in the background receives the latest data right after it returns to the foreground. 如果生命周期变为非活动状态，它将在再次变为活动状态时接收最新数据。 例如，后台活动在返回前台后立即接收最新数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设备唯一编码]]></title>
    <url>%2F2018%2F02%2F26%2F%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Android 设备唯一编码相信大家也会遇到一些唯一标识android设备的唯一性，但是android的权限越来越高，好多原来的方法不能使用了，整理一些放出来大家一起使用😎 1.IMEI 编码获取(平板没有)12345678TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);if (ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) &#123; //平板没有 15个数字 String imei = tm.getDeviceId(); if (!TextUtils.isEmpty(imei)) &#123; deviceId.append(imei); &#125;&#125; 2.通过Build获取一些信息1234567891011121314151617181920String manufacturer = Build.MANUFACTURER; deviceId.append(manufacturer); //WIFI MAC 地址 String localMac = getLocalMac(context); deviceId.append(localMac); String cpuAbi = Build.CPU_ABI; deviceId.append(cpuAbi); String radioVersion = Build.getRadioVersion(); deviceId.append(radioVersion); String board = Build.BOARD; deviceId.append(board); String brand = Build.BRAND; deviceId.append(brand); String device = Build.DEVICE; deviceId.append(device); String display = Build.DISPLAY; deviceId.append(display); String hardware = Build.HARDWARE; deviceId.append(hardware); 参数含义 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 3.获取网卡的Mac地址1234567891011121314151617181920212223242526272829303132333435363738/** * 获取设备MAC 地址 由于 6.0 以后 WifiManager 得到的 MacAddress得到都是 相同的没有意义的内容 * 所以采用以下方法获取Mac地址 * 需要 * &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; * &lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; * * @param context * @return */ private static String getLocalMac(Context context) &#123; String macAddress = null; StringBuffer buf = new StringBuffer(); NetworkInterface networkInterface = null; try &#123; networkInterface = NetworkInterface.getByName("eth1"); if (networkInterface == null) &#123; networkInterface = NetworkInterface.getByName("wlan0"); &#125; if (networkInterface == null) &#123; return ""; &#125; byte[] addr = networkInterface.getHardwareAddress(); for (byte b : addr) &#123; buf.append(String.format("%02X:", b)); &#125; if (buf.length() &gt; 0) &#123; buf.deleteCharAt(buf.length() - 1); &#125; macAddress = buf.toString(); &#125; catch (SocketException e) &#123; e.printStackTrace(); return ""; &#125; return macAddress; &#125; 4.获取蓝牙Mac地址123456789101112131415161718private String getBluetoothMac(final Context context) &#123; String result = null; if (context.checkCallingOrSelfPermission(Manifest.permission.BLUETOOTH) == PackageManager.PERMISSION_GRANTED) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; // Hardware ID are restricted in Android 6+ // https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-hardware-id // Getting bluetooth mac via reflection for devices with Android 6+ result = android.provider.Settings.Secure.getString(context.getContentResolver(), "bluetooth_address"); &#125; else &#123; BluetoothAdapter bta = BluetoothAdapter.getDefaultAdapter(); result = bta != null ? bta.getAddress() : ""; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>唯一编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM之ViewModel]]></title>
    <url>%2F2018%2F02%2F26%2Fandroid-2018-02-26-MVVM%E4%B9%8BViewModel%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[谷歌网址https://developer.android.com/topic/libraries/architecture/viewmodel#java ViewModelThe ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations. ViewModel类旨在以生命周期意识的方式存储和管理与UI相关的数据。 ViewModel类允许数据在配置更改（例如屏幕旋转）后继续存在。 The Android framework manages the lifecycles of UI controllers, such as activities and fragments. The framework may decide to destroy or re-create a UI controller in response to certain user actions or device events that are completely out of your control. If the system destroys or re-creates a UI controller, any transient UI-related data you store in them is lost. For example, your app may include a list of users in one of its activities. When the activity is re-created for a configuration change, the new activity has to re-fetch the list of users. For simple data, the activity can use the onSaveInstanceState() method and restore its data from the bundle in onCreate(), but this approach is only suitable for small amounts of data that can be serialized then deserialized, not for potentially large amounts of data like a list of users or bitmaps. Another problem is that UI controllers frequently need to make asynchronous calls that may take some time to return. The UI controller needs to manage these calls and ensure the system cleans them up after it’s destroyed to avoid potential memory leaks. This management requires a lot of maintenance, and in the case where the object is re-created for a configuration change, it’s a waste of resources since the object may have to reissue calls it has already made. UI controllers such as activities and fragments are primarily intended to display UI data, react to user actions, or handle operating system communication, such as permission requests. Requiring UI controllers to also be responsible for loading data from a database or network adds bloat to the class. Assigning excessive responsibility to UI controllers can result in a single class that tries to handle all of an app’s work by itself, instead of delegating work to other classes. Assigning excessive responsibility to the UI controllers in this way also makes testing a lot harder. It’s easier and more efficient to separate out view data ownership from UI controller logic. The lifecycle of a ViewModel 生命周期ViewModel objects are scoped to the Lifecycle passed to the ViewModelProvider when getting the ViewModel. The ViewModel remains in memory until the Lifecycle it’s scoped to goes away permanently: in the case of an activity, when it finishes, while in the case of a fragment, when it’s detached. ViewModel的生命周期在activity中时当onDestory之后结束，在fragment时在 detached之后结束。 Figure 1 illustrates （插图）the various lifecycle states of an activity as it undergoes（经历） a rotation and then is finished. The illustration also shows the lifetime of the ViewModel next to the associated activity lifecycle. This particular diagram illustrates the states of an activity. The same basic states apply to the lifecycle of a fragment. Share data between fragments 分享数据在fragment之间It’s very common that two or more fragments in an activity need to communicate with each other. Imagine(想象一下) a common case of master-detail fragments, where you have a fragment in which the user selects an item from a list and another fragment that displays the contents of the selected item. This case is never trivial(不重要的) as both fragments need to define some interface description, and the owner activity must bind the two together. In addition, both fragments must handle the scenario(场景) where the other fragment is not yet created or visible. This common pain point can be addressed by using ViewModel objects. These fragments can share a ViewModel using their activity scope to handle this communication, as illustrated by the following sample code: 123456789101112131415161718192021222324252627282930313233public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125;&#125;public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125;&#125;public class DetailFragment extends Fragment &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); model.getSelected().observe(this, &#123; item -&gt; // Update the UI. &#125;); &#125;&#125; Notice that both fragments retrieve the activity that contains them. That way, when the fragments each get the ViewModelProvider, they receive the same SharedViewModel instance, which is scoped to this activity. This approach offers the following benefits（好处）: The activity does not need to do anything, or know anything about this communication. Fragments don’t need to know about each other besides the SharedViewModel contract. If one of the fragments disappears, the other one keeps working as usual. Each fragment has its own lifecycle, and is not affected by the lifecycle of the other one. If one fragment replaces the other one, the UI continues to work without any problems. Replacing Loaders with ViewModel 替换加载器Loader classes like CursorLoader are frequently used to keep the data in an app’s UI in sync with a database. You can use ViewModel, with a few other classes, to replace the loader. Using a ViewModel separates your UI controller from the data-loading operation, which means you have fewer strong references between classes. In one common approach to using loaders, an app might use a CursorLoader to observe the contents of a database. When a value in the database changes, the loader automatically triggers a reload of the data and updates the UI: Figure 2. Loading data with loadersViewModel works with Room and LiveData to replace the loader. The ViewModel ensures that the data survives a device configuration change. Room informs your LiveData when the database changes, and the LiveData, in turn, updates your UI with the revised data. Figure 3. Loading data with ViewModel]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvvm框架搭建]]></title>
    <url>%2F2018%2F02%2F26%2Fandroid-2018-02-26-MVVM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[MVVM 框架搭建主要依赖包括 Lifecycles, LiveData, ViewModel, Room, and Paging.它还包括用于测试LiveData的测试助手以及测试Room迁移。 123456789101112131415161718dependencies &#123; // ViewModel and LiveData implementation &quot;android.arch.lifecycle:extensions:1.0.0&quot; annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0&quot; // Room implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot; annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot; // Paging implementation &quot;android.arch.paging:runtime:1.0.0-alpha4-1&quot; // Test helpers for LiveData testImplementation &quot;android.arch.core:core-testing:1.0.0&quot; // Test helpers for Room testImplementation &quot;android.arch.persistence.room:testing:1.0.0&quot;&#125; 对Java8支持1234dependencies &#123; // Java8 support for Lifecycles implementation &quot;android.arch.lifecycle:common-java8:1.0.0&quot;&#125; RxJava和ReactiveStreams的可选依赖项增加对RxJava和LiveData ReactiveStreams的可选支持。 1234567dependencies &#123; // RxJava support for Room implementation &quot;android.arch.persistence.room:rxjava2:1.1.0&quot; // ReactiveStreams support for LiveData implementation &quot;android.arch.lifecycle:reactivestreams:1.1.0&quot;&#125; 轻量级Lifecycles 导入12345dependencies &#123; // Lifecycles only (no ViewModel or LiveData) implementation &quot;android.arch.lifecycle:runtime:1.1.0&quot; annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.0&quot;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView的坑]]></title>
    <url>%2F2018%2F02%2F26%2Fandroid-WebView-03-WebView%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[WebView一、Webview常见的坑1.Android API level 16 以及之前的版本存在远程代码执行安全漏洞，该漏洞的源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java Relflection API 利用该漏洞执行任意Java对象的方法。2.webview 在布局文件中使用的时候，在界面销毁的时候先调用webView destroy() 方法,不然会造成内存泄漏。3.jsbridge 实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。 4.webviewClient.onPageFinished(不准确)-&gt;WebChromeClient.onProgressChanged 5、后台耗电的问题 6、硬件加速渲染界面，界面闪烁、白块等问题。 二、关于webview的内存泄漏的问题1、独立进程，简单暴力，不过涉及进程间通信2、动态添加WebView,对传入WebView中使用Context使用弱引用，动态添加WebView意思在布局中创建个ViewGroup用来放置WebView,Activity创建时add进来，在Activity remove调，然后再destory掉。]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView和Js交互方式]]></title>
    <url>%2F2018%2F02%2F26%2Fandroid-WebView-02-WebView%E5%92%8CJs%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.WebView和Js交互方式1.1 Android去调用JS的代码方式 对于android调用JS代码的方法有2种： 第一种方式已经不推荐使用了，第二种方式不仅更方便，也提供了结果的回调，但仅支持API 19以后的系统。12WebView.loadUrl("javascript:" + javascript);WebView.evaluateJavascript(javascript, callbacck); 1.2 JS去调用Android的代码方式 对于JS调用Android代码的方法有3种： 第一种：通过WebView的addJavascriptInterface（）进行对象映射 第二种：通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 第三种：通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt()消息 第一种 addJavascriptInterface根据安卓官方的api说明，addJavaScriptInterface方法存在安全漏洞。因为JS可以通过反射访问注入对象。官方在4.2及以后的系统中修复了该问题，要求注入的远程方法必须使用注解@JavascriptInterface 1234567891011 //允许运行js代码mWebView.getSettings().setJavaScriptEnabled(true); class JsObject &#123; @JavascriptInterface public String toString() &#123; return "injectedObject"; &#125; &#125; webView.addJavascriptInterface(new JsObject(), "injectedObject"); //JS调用注入对象示例【java代码】webView.loadUrl("javascript:alert(injectedObject.toString())"); ​ 第二种 shouldOverrideUrlLoading回调拦截WebViewClient.shouldOverrideUrlLoading() 123456789101112131415161718192021222324252627282930 @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if ( TextUtils.isEmpty(url) ) &#123; return false; &#125; // 通用url跳转规则 if ( TbUrlBridge.overrideUrl(TbWebViewActivity.this, url) ) &#123; return true; &#125; else &#123; // 非通用url规则，则用当前webview直接打开 try &#123; if(url.startsWith("weixin://") //微信 || url.startsWith("alipays://") //支付宝 || url.startsWith("mailto://") //邮件 || url.startsWith("tel://")//电话 || url.startsWith("baidumap://")//大众点评 //其他自定义的scheme ) &#123;// Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));// startActivity(intent); return true; &#125; &#125; catch (Exception e) &#123; //防止crash (如果手机上没有安装处理某个scheme开头的url的APP, 会导致crash) return true;//没有安装该app时，返回true，表示拦截自定义链接，但不跳转，避免弹出上面的错误页面 &#125; mUrl = url; refresh(); &#125; return super.shouldOverrideUrlLoading(view, url); &#125; 第三种 onJsAlert，onJsConfirm，onJsPrompt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** * Tell the client to display a javascript alert dialog. If the client * returns true, WebView will assume that the client will handle the * dialog. If the client returns false, it will continue execution. * @param view The WebView that initiated the callback. * @param url The url of the page requesting the dialog. * @param message Message to be displayed in the window. * @param result A JsResult to confirm that the user hit enter. * @return boolean Whether the client will handle the alert dialog. */ public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; return false; &#125; /** * Tell the client to display a confirm dialog to the user. If the client * returns true, WebView will assume that the client will handle the * confirm dialog and call the appropriate JsResult method. If the * client returns false, a default value of false will be returned to * javascript. The default behavior is to return false. * @param view The WebView that initiated the callback. * @param url The url of the page requesting the dialog. * @param message Message to be displayed in the window. * @param result A JsResult used to send the user's response to * javascript. * @return boolean Whether the client will handle the confirm dialog. */ public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; return false; &#125; /** * Tell the client to display a prompt dialog to the user. If the client * returns true, WebView will assume that the client will handle the * prompt dialog and call the appropriate JsPromptResult method. If the * client returns false, a default value of false will be returned to to * javascript. The default behavior is to return false. * @param view The WebView that initiated the callback. * @param url The url of the page requesting the dialog. * @param message Message to be displayed in the window. * @param defaultValue The default value displayed in the prompt dialog. * @param result A JsPromptResult used to send the user's reponse to * javascript. * @return boolean Whether the client will handle the prompt dialog. */ public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; return false; &#125;//控制台log /** * Report a JavaScript console message to the host application. The ChromeClient * should override this to process the log message as they see fit. * @param consoleMessage Object containing details of the console message. * @return true if the message is handled by the client. */WebChromeClient.onConsoleMessage() https://www.jianshu.com/p/7d820c00642a 2.Android调用JS脚本 对于Android调用JS代码的方法有2种： 通过WebView的loadUrl（） 通过WebView的evaluateJavascript（） 2.1 通过WebView的evaluateJavascript() 优点：该方法比第一种方法效率更高、使用更简洁。 因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。 Android 4.4 后才可使用123456789101112131415161718192021222324//只需要将第一种方法的loadUrl()换成下面该方法即可 /** * Asynchronously evaluates JavaScript in the context of the currently displayed page. * If non-null, |resultCallback| will be invoked with any result returned from that * execution. This method must be called on the UI thread and the callback will * be made on the UI thread. * &lt;p&gt; * Compatibility note. Applications targeting &#123;@link android.os.Build.VERSION_CODES#N&#125; or * later, JavaScript state from an empty WebView is no longer persisted across navigations like * &#123;@link #loadUrl(String)&#125;. For example, global variables and functions defined before calling * &#123;@link #loadUrl(String)&#125; will not exist in the loaded page. Applications should use * &#123;@link #addJavascriptInterface&#125; instead to persist JavaScript objects across navigations. * * @param script the JavaScript to execute. * @param resultCallback A callback to be invoked when the script execution * completes with the result of the execution (if any). * May be null if no notification of the result is required. */mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125;&#125;); 2.2 通过WebView的loadUrl() 直接Webview调用loadUrl方法，里面是JS的方法名，并可以传入参数，javascript：xxx()方法名需要和JS方法名相同 contentWebView.loadUrl(“javascript:javacalljs()”); HTML代码 1234 function alertFun() &#123; alert("Alert警告对话框!");&#125; 1webView.loadUrl("javascript:alertFun()"); 2.3 使用建议1234567891011121314两种方法混合使用，即Android 4.4以下使用方法1，Android 4.4以上方法2//Android版本变量final int version = Build.VERSION.SDK_INT;//因为该方法在 Android 4.4 版本才可使用，所以使用时需进行版本判断if (version &lt; 18) &#123; mWebView.loadUrl("javascript:callJS()");&#125; else &#123; mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;);&#125; 3.什么时候注入js探索 3.1 onPageFinished()或者onPageStarted()方法中注入js代码 做过WebView开发，并且需要和js交互，大部分都会认为js在WebViewClient.onPageFinished()方法中注入最合适，此时dom树已经构建完成，页面已经完全展现出来。但如果做过页面加载速度的测试，会发现WebViewClient.onPageFinished()方法通常需要等待很久才会回调（首次加载通常超过3s），这是因为WebView需要加载完一个网页里主文档和所有的资源才会回调这个方法。 能不能在WebViewClient.onPageStarted()中注入呢？答案是不确定。经过测试，有些机型可以，有些机型不行。在WebViewClient.onPageStarted()中注入还有一个致命的问题——这个方法可能会回调多次，会造成js代码的多次注入。 从7.0开始，WebView加载js方式发生了一些小改变，官方建议把js注入的时机放在页面开始加载之后。 3.2 WebViewClient.onProgressChanged()方法中注入js代码** WebViewClient.onProgressChanged()这个方法在dom树渲染的过程中会回调多次，每次都会告诉我们当前加载的进度。 在这个方法中，可以给WebView自定义进度条，类似微信加载网页时的那种进度条 如果在此方法中注入js代码，则需要避免重复注入，需要增强逻辑。可以定义一个boolean值变量控制注入时机 那么有人会问，加载到多少才需要处理js注入逻辑呢？ 正是因为这个原因，页面的进度加载到80%的时候，实际上dom树已经渲染得差不多了，表明WebView已经解析了标签，这时候注入一定是成功的。在WebViewClient.onProgressChanged()实现js注入有几个需要注意的地方： 6.2.1 上文提到的多次注入控制，使用了boolean值变量控制 6.2.2 重新加载一个URL之前，需要重置boolean值变量，让重新加载后的页面再次注入js 6.2.3 如果做过本地js，css等缓存，则先判断本地是否存在，若存在则加载本地，否则加载网络js 6.2.4 注入的进度阈值可以自由定制，理论上10%-100%都是合理的，不过建议使用了75%到90%之间可以。 7.H5页面点击图片监听图片链接地址12345678910111213141516171819202122232425262728settings.setJavaScriptEnabled(true);wv_view.addJavascriptInterface(new ImageJs(this),"imageListener");/**打开图片js通信接口*/private class ImageJs &#123; private final Activity activity; public ImageJs(Activity activity) &#123; this.activity = activity; &#125; // 下面的@SuppressLint("JavascriptInterface")最好加上。防止在某些版本中js和java的交互不支持。 //@SuppressLint("JavascriptInterface") @android.webkit.JavascriptInterface public void openImage(String img) &#123; Log.i("url地址","图片"+ img); //跳转页面 &#125;&#125;/**添加图片点击事件的js代码，网上找到，就是这样写，不需要明白*/private void addImageClickListner() &#123; String jsCode="javascript:(function()&#123;" + "var imgs=document.getElementsByTagName(\"img\");" + "for(var i=0;i&lt;imgs.length;i++)&#123;" + "imgs[i].onclick=function()&#123;" + "window.imageListener.openImage(this.src);" + //imageListener自定义，openImage要与js通信接口相同 "&#125;&#125;&#125;)()"; wv_view.loadUrl(jsCode);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView基础]]></title>
    <url>%2F2018%2F02%2F25%2Fandroid-WebView-01-WebView%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.WebView最简单的使用方法 布局 1234&lt;WebView android:id="@+id/webView" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; 在activity中最简单的使用 12345678910111213webview = (WebView) findViewById(R.id.webView);//加载web资源webview.loadUrl("http://www.baidu.com/");//加载本地资源webView.loadUrl("file:///android_asset/example.html"); 这个时候发现一个问题，启动应用后，自动的打开了系统内置的浏览器，解决这个问题需要为webview设置 WebViewClient，并重写方法：webview.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true;//true 调用Webview,false调用第三方。 &#125;&#125;); 2.WebView的常用方法2.1 WebView回退等功能12345678910111213141516webView.canGoBack();//判断是否有可以回退，可以返回truewebView.goBack();//返回上一层级webView.canGoForward();//判断是否可以前进，可以返回truewebView.goForward();//进入上一层级webView.reload();//刷新@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123;//改写物理按键——返回的逻辑 这个很重要 if(keyCode==KeyEvent.KEYCODE_BACK) &#123; if(wv.canGoBack()) &#123; wv.goBack(); return true; &#125; &#125; return super.onKeyDown(keyCode, event);&#125; 2.2 WebView的状态12345678910111213141516171819//激活WebView为活跃状态，能正常执行网页的响应webView.onResume() ；//当页面被失去焦点被切换到后台不可见状态，需要执行onPause//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。webView.onPause()；//当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。webView.pauseTimers()恢复pauseTimers状态webView.resumeTimers()；销毁Webview/**在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview但是注意：webview调用destory时,webview仍绑定在Activity上,这是由于自定义webview构建时传入了该Activity的context对象,因此需要先从父容器中移除webview,然后再销毁webview:**/rootLayout.removeView(webView);webView.destroy(); 2.3 清除缓存数据1234567//清除网页访问留下的缓存//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.Webview.clearCache(true);//清除当前webview访问的历史记录,只会webview访问历史记录里的所有记录除了当前访问记录Webview.clearHistory()；//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据Webview.clearFormData()； 3.WebView常用类的介绍3.1 WebSettings类 主要的作用对WebView进行配置和管理1234567891011121314151617181920212223242526272829303132333435363738394041//声明WebSettings子类WebSettings webSettings = webView.getSettings();//注意：这个很重要 如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持插件webSettings.setPluginsEnabled(true);//设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小webSettings.setLoadWithOverviewMode(true); //缩放至屏幕的大小//缩放操作webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件//其他细节操作webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存webSettings.setAllowFileAccess(true); //设置可以访问文件webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式/**设置WebView缓存当加载 html 页面时，WebView会在/data/data/包名目录下生成 database 与 cache 两个文件夹请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下是否启用缓存：**///优先使用缓存:WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//缓存模式如下：//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。//不使用缓存:WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能webSettings.setDatabaseEnabled(true); //开启 database storage API 功能webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;webSettings.setAppCachePath(cacheDirPath); //设置 Application Caches 缓存目录 3.2 WebViewClient类 主要的作用是处理各种通知和请求事件 shouldOverrideUrlLoading()方法 12345678shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;); onPageStarted() 1234567//作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; //开始加载网页 &#125;&#125;); onPageFinished() 1234567//作用：在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; //网页加载完成 &#125;&#125;); onLoadResource() 1234567//作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean onLoadResource(WebView view, String url) &#123; //设定加载资源的操作 &#125;&#125;); onReceivedError() //加载出错的时候 1234567891011121314151617作用：加载页面的服务器出现错误时（如404）调用。App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面//步骤2：将该html文件放置到代码根目录的assets文件夹下//步骤3：复写WebViewClient的onRecievedError方法//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理webView.setWebViewClient(new WebViewClient()&#123; @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl)&#123; switch(errorCode)&#123; case HttpStatus.SC_NOT_FOUND: view.loadUrl("file:///android_assets/error_handle.html"); break; &#125; &#125;&#125;); onReceivedSslError() https处理 1234567891011作用：处理https请求webView默认是不处理https请求的，页面显示空白，需要进行如下设置：webView.setWebViewClient(new WebViewClient() &#123; @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123; handler.proceed(); //表示等待证书响应 // handler.cancel(); //表示挂起连接，为默认方式 // handler.handleMessage(null); //可做其他处理 &#125; &#125;); 4.3 WebChromeClient类 主要的作用是辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等 onProgressChanged() onReceivedTitle()123456789101112131415161718作用：获得网页的加载进度并显示webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; if (newProgress &lt; 100) &#123; String progress = newProgress + "%"; progress.setText(progress); &#125; &#125; /** 作用：获取Web页中的标题 每个网页的页面都有一个标题 **/ @Override public void onReceivedTitle(WebView view, String title) &#123; titleview.setText(title)； &#125;&#125;); 5.WebView注意事项5.1 动态创建WebView使用上下文为全局上下文1234LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);mWebView = new WebView(getApplicationContext());mWebView.setLayoutParams(params);mLayout.addView(mWebView); 5.2 Activity销毁的时候，销毁WebView12345678910111213//在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。@Overrideprotected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; &#125; super.onDestroy();&#125; 5.3 WebView页面中播放了音频,退出Activity后音频仍然在播放，需要在Activity的onDestory()中调用12345678910111213141516@Overrideprotected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); mWebView.clearHistory(); ViewGroup parent = (ViewGroup) mWebView.getParent(); if (parent != null) &#123; parent.removeView(mWebView); &#125; mWebView.removeAllViews(); mWebView.destroy(); mWebView = null; &#125; super.onDestroy();&#125; 6.WebView滑动监听6.1 WebView滑动监听事件1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NewWebView extends WebView&#123; private OnScrollChangeListener mOnScrollChangeListener; public NewWebView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** 以屏幕的左上角为（0,0）点，l表示滑动后的x值，oldl表示滑动前的x位置,t表示滑动后的y值，oldt表示滑动前的y位置。 **/ @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123; super.onScrollChanged(l, t, oldl, oldt);/**getScrollY()方法返回的是当前可见区域的顶端距整个页面顶端的距离,也就是当前内容滚动的距离。getHeight()或者getBottom()方法都返回当前WebView 这个容器的高度,getContentHeight 返回的是整个html 的高度,但并不等同于当前整个页面的高度,因为WebView 有缩放功能, 所以当前整个页面的高度实际上应该是原始html 的高度再乘上缩放比例getScale(). 因此,更正后的结果,准确的判断方法应该是：**/ // webview的高度 float webcontent = getContentHeight() * getScale(); // 当前webview的高度 float webnow = getHeight() + getScrollY(); if (Math.abs(webcontent - webnow) &lt; 1) &#123; //处于底端 mOnScrollChangeListener.onPageEnd(l, t, oldl, oldt); &#125; else if (getScrollY() == 0) &#123; //处于顶端 mOnScrollChangeListener.onPageTop(l, t, oldl, oldt); &#125; else &#123; mOnScrollChangeListener.onScrollChanged(l, t, oldl, oldt); &#125; &#125; public void setOnScrollChangeListener(OnScrollChangeListener listener) &#123; this.mOnScrollChangeListener = listener; &#125; public interface OnScrollChangeListener &#123; public void onPageEnd(int l, int t, int oldl, int oldt); public void onPageTop(int l, int t, int oldl, int oldt); public void onScrollChanged(int l, int t, int oldl, int oldt); &#125; &#125; 7.WebView其他使用7.1 如何调试WebView加载的页面？ 在Android 4.4版本以后，可以使用Chrome开发者工具调试WebView内容5。调试需要在代码里设置打开调试开关。 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true);&#125; 开启后，使用USB连接电脑，加载URL时，打开Chrome开发者工具，在浏览器输入 1chrome://inspect/#devices 可以看到当前正在浏览的页面，点击inspect即可看到WebView加载的内容。 7.2 WebView中部分Settings方法介绍123456789101112131415161718192021222324252627282930313233343536373839setSupportZoom(boolean support) //是否支持缩放，配合方法setBuiltInZoomControls使用，默认truesetMediaPlaybackRequiresUserGesture(boolean require) //是否需要用户手势来播放Media，默认truesetDisplayZoomControls(boolean enabled) //是否显示窗口悬浮的缩放控制，默认truesetAllowFileAccess(boolean allow) //是否允许访问WebView内部文件，默认truesetAllowContentAccess(boolean allow) //是否允许获取WebView的内容URL setLoadWithOverviewMode(boolean overview) //是否启动概述模式浏览界面，当页面宽度超过WebView显示宽度时，缩小页面适应WebView。默认falsesetSaveFormData(boolean save) //是否保存表单数据，默认falsesetTextZoom(int textZoom) //设置页面文字缩放百分比，默认100%setUseWideViewPort(boolean use) //是否支持ViewPort的meta tag属性setSupportMultipleWindows(boolean support) //是否支持多窗口setLayoutAlgorithm(LayoutAlgorithm l) //指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认LayoutAlgorithm#NARROW_COLUMNSsetStandardFontFamily(String font) //设置标准的字体族，默认”sans-serif”。font-family 规定元素的字体系列。setFixedFontFamily(String font) //设置混合字体族。默认”monospace”setSansSerifFontFamily(String font) //设置SansSerif字体族。默认”sans-serif”setSerifFontFamily(String font) //设置SerifFont字体族，默认”sans-serif”setCursiveFontFamily(String font) //设置CursiveFont字体族，默认”cursive”setFantasyFontFamily(String font) //设置FantasyFont字体族，默认”fantasy”setMinimumFontSize(int size) //设置最小字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。setMinimumLogicalFontSize(int size) //设置最小逻辑字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。setDefaultFontSize(int size) //设置默认字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。setDefaultFixedFontSize(int size) //设置默认填充字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。setLoadsImagesAutomatically(boolean flag) //设置是否加载图片资源setBlockNetworkImage(boolean flag) //是否加载网络图片资源。setBlockNetworkLoads(boolean flag) //设置是否加载网络资源setJavaScriptEnabled(boolean flag) //设置是否允许执行JSsetAllowUniversalAccessFromFileURLs(boolean flag) //是否允许Js访问任何来源的内容setAllowFileAccessFromFileURLs(boolean flag) //是否允许Js访问其他file scheme的URLs。setGeolocationDatabasePath(String databasePath) //设置存储定位数据库的位置setAppCacheEnabled(boolean flag) //是否允许Cache，默认false。setAppCachePath(String appCachePath) //设置Cache API缓存路径。setDatabaseEnabled(boolean flag) //是否允许数据库存储。默认false。setDomStorageEnabled(boolean flag) //是否存储页面DOM结构，默认falsesetGeolocationEnabled(boolean flag) //是否允许定位，默认true。setJavaScriptCanOpenWindowsAutomatically(boolean flag) //是否允许JS自动打开窗口。默认falsesetDefaultTextEncodingName(String encoding) //设置页面的编码格式，默认UTF-8setUserAgentString(String ua) //设置WebView代理，默认使用默认值setNeedInitialFocus(boolean flag) //通知WebView是否需要设置一个节点获取焦点当setCacheMode(int mode) //基于WebView导航的类型使用缓存setMixedContentMode(int mode) //设置加载不安全资源的WebView加载行为 7.3 加载证书错误 webview加载一些别人的url时候，有时候会发生证书认证错误的情况，这时候我们希望能够正常的呈现页面给用户，我们需要忽略证书错误，需要调用WebViewClient类的onReceivedSslError方法，调用handler.proceed()来忽略该证书错误。]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下常用软件、插件和驱动]]></title>
    <url>%2F2018%2F02%2F25%2Fmac%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E3%80%81%E6%8F%92%E4%BB%B6%E5%92%8C%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[一.常用免费 QQ 微信 QQ音乐 网易云音乐 搜狗输入法 TeamViewer Maipo 极致微博 12306 订票助手 ShadowsocksX-R iHost Hosts编辑器 live-recorder Bilibili录播机 iPic - 图床神器/支持 Markdown Thunder For Mac（备用会员版本） HandShaker Android手机文件管理 二.应用软件 Pixave 设计素材管理 Leaf RSS 新闻阅读器 Google Earth 谷歌地球 Quiver 程序猿的笔记本 Ulysses MD文本编辑器 1Password 密码管理工具 BetterZip 快速的压缩工具 Fantastical 优雅的日历软件 Airmail 最佳Mac邮件客户端 Tweetbot 优秀Twitter客户端 Papers 专业的文献管理工具 MindNode Pro 思维导图工具 iThoughtsX 优秀思维导图工具 DropDMG 轻松制作DMG文件 欧路词典 专为MAC而生的词典 Instant Translate 即时翻译工具 iSmartPhoto 看图&amp;相片智能管理 Reeder 将RSS阅读体验发挥到极致 4K Stogram 批量下载Instagram图片 Instastack 简单实用instagram客户端 PDF Expert 极致的PDF阅读标注工作体验 Alternote 第三方印象笔记Evernote 客户端 MWeb 专业的Markdown写作/记笔记/静态博客生成软件 三.媒体工具 VOX 全能音乐播放器 SPlayerX 射手播放器 Simplify 简单音乐控制器 ScreenFlow 屏幕录像软件 Motion 视频后期特效制作 FxFactory 视觉特效插件包 MPlayerX 开源视频播放应用 iMovie 苹果官方视频剪辑软件 Audirvana Plus 无损音乐播放器 VideoGIF 将视频剪辑为GIF动画 iFFmpeg Mac专业的视频压制软件 Final Cut Pro 专业级视频剪辑软件 VideoToolbox 简单好用的视频编辑工具 DaVinci Resolve Studio Mac顶级调色软件 Wondershare Video Converter Ultimate 万能视频格式转换器 四.网络工具 SiteSucker 扒站神器 Downie 视频下载工具 Folx Pro Mac下载工具 Charles Mac上的抓包工具 SSH Shell 便捷易用高颜值 Surge 必备的网络调试工具 Softorino YouTube Converte 五.开发工具 iTerm Xcode Atom For Mac Android Studio SourceTree Github管理 Sublime Text 3 for mac Dash 开发者必备 API文档聚合 Regextor 正则表达式测试工具 Navicat Premium 数据库管理工具 MyEclipse 2015 Java集成开发工具 Cornerstone Mac上最好用的SVN客户端 MAMP Pro for Mac 集成Web服务器环境 Beyond Compare for mac 文件对比利器 Araxis Merge 可视化文件对比合并同步工具 六.图形设计 Sip Pro 屏幕取色工具 Flinto 交互式设计神器 StarUML UML设计工具 IconKit 应用图标制作工具 Framer 移动交互原型设计工具 Principle Mac交互动效设计神器 Sketch 轻量易用的矢量设计工具 SkyLab Studio 为你的照片换个天 PaintCode 专业矢量图形绘图工具 PaintCode for Sketch 将绘图转为代码 Hype Pro 不会html5也能做出漂亮的动画 Axure RP Team Edition 专业的快速原型设计工具 Affinity Designer 迅捷/流畅/精确的矢量图形设计工具 Affinity Photo 专业级修图软件 七.行业软件 Deckset 幻灯片制作工具 Money Pro 同步账单/预算和账户 EndNote X8 论文参考文献管理工具 AutoCAD 2016 For Mac 强大的CAD绘图工具 EdrawMax 亿图图示专家 基于矢量的绘图工具 MATLAB R2016b for Mac 强大的商业数学软件 八.系统工具 Alfred 效率神器 Disk Drill 数据恢复工具 UninstallPKG 卸载工具 DaisyDisk 系统清理工具 CleanMyMac Mac中文版 CCleaner Pro 系统垃圾清扫软件 iStat Menus 优秀的系统监控工具 VMware Fusion 强大的虚拟机应用 Parallels Desktop 最佳Mac虚拟机解决方案 Moom 窗口布局工具 Boom 2 音效增强工具 Boom 3D 音效增强工具 RightFont 字体管理工具 TotalFinder Finder增强工具 Backgrounds 系统增强及美化工具 Tuxera NTFS 2016 让你的Mac支持NTFS Path Finder 超赞Mac资源 文件管理工具 OS X Server 5.2 让整个团队更高效地分享信息 九.OmniKit OmniGraffle Pro 强大的图形工具 OmniFocus 强大的任务管理软件 OmniOutliner Pro 日常工作想法记录 OmniPlan 专业版 最NB的项目管理流程软件 十.AdobeKit Adobe Photoshop CC 2017（附中文语言包） Adobe Experience Design CC 原型制作工具 Adobe Audition CC 2017 强大音频编辑工具 Adobe Animate CC Adobe全新动画制作工具 Adobe InDesign CC 2017 桌面出版与设计软件 Adobe Acrobat Pro DC 2015 强大的PDF编辑软件 Adobe Premiere Pro CC 2015 强大的视频编辑软件 Adobe Muse CC 2017 Adobe illustrator CC 2017 Adobe Lightroom CC 2015 Adobe After Effects CC 2015 Adobe Dreamweaver CC 2017 十一.OfficeKit iWork Pages iWork Keynote iWork Numbers Microsoft Office for Mac 2016 十二.JetbrainsKit IntelliJ IDEA Ultimate Edition 2017 Java开发工具 AppCode 2017 Objective-C集成开发环境 WebStorm 2017 Web前端开发神器 PHPStorm 2017 PHP IDE开发工具 RubyMine 2017 Ruby/Rails的IDE PyCharm 2017 Python IDE工具 DataGrip 2017 数据库管理工具 CLion 2017 C/C++开发工具 十三.Chrome应用扩展 划词翻译 哔哩哔哩助手 Infinity新标签页 Google学术搜索按钮 FireShot捕捉网页截图 Holmes 书签/历史搜索 ColorZilla 网页取色工具 Tampermonkey 油猴脚本 WEB前端助手（FeHelper） Stylish-为任意网站自定义主题 Octotree Github-plus qiniu upload files Bookmark Manager LastPass: PWManager Voblet GitHub Bookmark 十四.HackintoshKit Clover Configurator 助手工具 Clover EFI Bootloader 引导工具 ESP Mounter Pro 装载EFI分区 AppleHDA Patcher 声卡驱动工具 EasyKext Pro 驱动安装和权限修复 KCPM Utility Pro 驱动安装和权限修复 LazyHackintoshGenerator 镜像制作工具 Patch-Nvme FireWolf OS X PE V7.0 VMware Unlocker for OS X Acpica iasl 反编译脚步工具 MaciASL DSDT和SSDT工具 OS-X-Clover-Laptop-Config NVIDIA® WebDriver Updater CPU-S CPU变频测试 Geekbench 4 跑分测试 CINEBENCH R15 跑分测试 十五.常用驱动 RehabMan Bitbucket 驱动&amp;工具 AppleALC Native macOS HD audio Lilu Arbitrary kext and Process Patching OS-X-Fake-PCI-ID OS-X-USBInject-All OS-X-Intel-Network OS-X-Intel-Backlight OS-X-Realtek-Network OS-X-BrcmPatchRAM OS-X-FakeSMC-kozlek OS-X-ACPI-Battery-Driver OS-X-Voodoo-PS2-Controller OS-X-EAPD-Codec-Commander]]></content>
      <categories>
        <category>笔记本</category>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下内网穿透工具]]></title>
    <url>%2F2018%2F02%2F24%2FMac%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[natapp是基于ngrok的国内高速内网穿透专业服务商，适用于微信开发调试,本地架设演示服务器,外网可以访问,远程服务器等。 官网链接 使用方法1.在开始之前，我们需要先注册一下，这里很简单，只要输入手机号和验证码就可以注册了2.注册完之后，我们登入可以看到界面的左侧菜单栏，点击购买隧道，这里我选择免费隧道3.需要实名认证4.然后就可以使用免费的通道了将下载的文件设置可以执行权限 1chmod u+x natapp 开始运行 1./natapp -authtoken=********]]></content>
      <categories>
        <category>网络</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>微信开发</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP(传输层) Socket]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%BD%91%E7%BB%9C-2017-01-18-TCP%E5%92%8CUDP-%E4%BC%A0%E8%BE%93%E5%B1%82-%E3%80%81Socket%2F</url>
    <content type="text"><![CDATA[1.TCP和UDP的区别1.1 TCP和UDP的区别 ①UDP协议： 面向无连接 每个数据报的大小在限制在64k内 因为是面向无连接，所以是不可靠协议 不需要建立连接，速度快 ②TCP协议： 必须建立连接，形成传输数据的通道 在连接中可进行大数据量传输 通过三次握手完成连接，是可靠协议 必须建立连接，效率会稍低 注：三次握手： 第一次：我问你：在么？ 第二次：你回答：在。 第三次：我反馈：哦，我知道你在。 2.Socket介绍2.1 Socket简单介绍 Socket简单介绍 Socket就是为网络服务提供的一种机制 通信的两端都有Socket 网络通信其实就是Socket间的通信 数据在两个Socket间通过IO传输 玩Socket主要就是记住流程，代码查文档就行 Socket的简单使用的话应该都会，两个端各建立一个Socket，服务端的叫ServerSocket，然后建立连接即可。 2.2 Socket工作图解 3.UDP协议传输数据3.1 客户端发送数据123456789101112131415161718192021222324252627282930/** * 端口号 */private static final int PORT = 8080;/* * UDP协议发送数据： * 1.创建发送端Socket对象 * 2.创建数据，并把数据打包 * 3.调用Socket对象发送方法发送数据包 * 4.释放资源 */private void udpSendMessage(String serverAddress) &#123; String content = "yang"; // 创建发送端Socket对象 try &#123; // 创建发送端Socket对象 DatagramSocket ds = new DatagramSocket(); // 创建数据，并把数据打包 byte[] bys = content.getBytes(); InetAddress byName = InetAddress.getByName(serverAddress); DatagramPacket dp = new DatagramPacket(bys, bys.length,byName ,PORT); // 调用Socket对象发送方法发送数据包 ds.send(dp); // 释放资源 ds.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.2 服务端接收数据12345678910111213141516171819202122232425262728293031/* * UDP协议接收数据： * 1.创建接收端Socket对象 * 2.创建一个数据包(接收容器) * 3.调用Socket对象接收方法接收数据包 * 4.解析数据包 * 5.释放资源 */private void receive_udp() &#123; try &#123; // 创建接收端Socket对象 DatagramSocket ds = new DatagramSocket(PORT); // 创建一个数据包(接收容器) byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); // 调用Socket对象接收方法接收数据包 ds.receive(dp); // 获取对方的ip String ip = dp.getAddress().getHostAddress(); // 解析数据 String data = new String(dp.getData(), 0, dp.getLength()); Message message = new Message(); message.obj = data; message.what = 2; handler.sendMessage(message); // 关闭数据库 ds.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 4.TCP协议传输数据4.1 客户端发送数据1234567891011121314151617181920212223242526/** * 端口号 */private static final int PORT = 8080;/** * @param serverAddress 要发送到服务端的ip * 1.创建socket并指定ip和端口号 * 2.获取输出流，写数据 * 3.释放资源 * 4.Tcp一定要先开接收端 */public void send_tcp(String serverAddress) &#123; try &#123; Socket s = new Socket(serverAddress, PORT); //为了发送数据，应该获得socket流中的输出流 OutputStream out = s.getOutputStream(); String content = "yang"; out.write(content.getBytes()); s.close(); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 4.2 服务端接收数据12345678910111213141516171819202122232425262728293031323334353637/** * TCP协议接收数据 * 1.创建接收端的Socket对象 * 2.监听客户端接收，返回一个Socket对象 * 3.获取输入流，读取数据显示在控制台 * 4.释放资源 */public void receive_tcp() &#123; try &#123; //1.建立连接，监听端口 ServerSocket ss = new ServerSocket(PORT); //2.连接客户端对象 while (true) &#123; //阻塞式方法，只有客户端连接了才会继续往下运行 Socket accept = ss.accept(); //获取ip String ip = accept.getInetAddress().getHostAddress(); //3.获取客户端发送过来的数据 InputStream in = accept.getInputStream(); //4.开始读取,获取输入信息 BufferedReader bff = new BufferedReader(new InputStreamReader(in)); //读取信息 String line; final StringBuilder sb = new StringBuilder(); while ((line = bff.readLine()) != null) &#123; sb.append(line); &#125; Message message = new Message(); message.obj = sb.toString(); handler.sendMessage(message); //5.关闭 //ss.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 5.三次握手建立连接5.1 三次握手原理图 第一次：发送SNY=1表示此次握手是请求建立连接的，然后seq生成一个客户端的随机数X 第二次：发送SNY=1,ACK=1表示是回复请求建立连接的，然后ack=客户端的seq+1（这样客户端收到后就能确认是之前想要连接的那个服务端），然后把服务端也生成一个代表自己的随机数seq=Y发给客户端。 第三次：ACK=1。 seq=客户端随机数+1，ack=服务端随机数+1（这样服务端就知道是刚刚那个客户端了） 5.2 为什么建立连接需要三次握手 首先非常明确的是两次握手是最基本的，第一次握手，C端发了个连接请求消息到S端，S端收到后S端就知道自己与C端是可以连接成功的，但是C端此时并不知道S端是否接收到这个消息，所以S端接收到消息后得应答，C端得到S端的回复后，才能确定自己与S端是可以连接上的，这就是第二次握手。 C端只有确定了自己能与S端连接上才能开始发数据。所以两次握手肯定是最基本的。 那么为什么需要第三次握手呢？假设一下如果没有第三次握手，而是两次握手后我们就认为连接建立，那么会发生什么？ 第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误 具体情况就是： C端发出去的第一个网络连接请求由于某些原因在网络节点中滞留了，导致延迟，直到连接释放的某个时间点才到达S端，这是一个早已失效的报文，但是此时S端仍然认为这是C端的建立连接请求第一次握手，于是S端回应了C端，第二次握手。 如果只有两次握手，那么到这里，连接就建立了，但是此时C端并没有任何数据要发送，而S端就会傻傻的等待着，造成很大的资源浪费。所以需要第三次握手，只有C端再次回应一下，就可以避免这种情况。 5.3 四次握手断开连接 如图所示： 经过上面的建立连接图的解析，这个图应该不难看懂，这里主要有一个问题：为什么比建立连接时多了一次握手？ 可以看到这里服务端的ACK(回复客户端)和FIN(终止)消息并不是同时发出的，而是先ACK，然后再FIN，这也很好理解，当客户端要求断开连接时，此时服务端可能还有未发送完的数据，所以先ACK，然后等数据发送完再FIN。这样就变成了四次握手了。]]></content>
      <categories>
        <category>网络</category>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程基础知识]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%BD%91%E7%BB%9C-2017-01-18-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[网络编程基础知识1.网络模型概述和图解1.1 网络模型概述 计算机网络之间以何种规则进行通信，就是网络模型研究问题。 网络模型一般是指OSI（Open System Interconnection开放系统互连）七层参考模型 TCP/IP四层参考模型主机至网络层(物理层 , 数据链路层) , 网际层 , 传输层 , 应用层(应用层 , 表示层 , 会话层) 1.2 网络模型7层概述 1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0）。这一层的数据叫做比特。 2.数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 3.网络层：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）.主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。 主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 6.表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 7.应用层： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。 2.网络编程三要素 A:IP地址:InetAddress: 网络中设备的标识，不易记忆，可用主机名 B:端口号: 用于标识进程的逻辑地址，不同进程的标识 C:传输协议: 通讯的规则常见协议：TCP，UDP 2.1 端口 物理端口 网卡口 逻辑端口 我们指的就是逻辑端口 a:每个网络程序都会有一个逻辑端口 b:用于标识进程的逻辑地址，不同进程的标识 c:有效端口：0~65535，其中0~1024系统使用或保留端口。 2.2 协议（运输层） 用户数据报协议( User Datagram Protocol,UDP) 将数据源和目的封装成数据包中，不需要建立连接； 每个数据报的大小在限制在64k； 因无连接，是不可靠协议； 不需要建立连接，速度快 传输控制协议(Transmission Control Protocol, TCP) 建立连接，形成传输数据的通道； 在连接中进行大数据量传输； 需要连接所以是可靠协议； 必须建立连接，效率会稍低 流控制传输协议( Stream Control Transmission Protocol, SCTP) 口SCTP结合了UDP和TCP的优点。SCTP是可靠的面向报文的协议。它保留了报文的边界，与此同时也检测丢失的数据、重复的数据以及失序的数据。SCTP还有拥塞控制和流量控制机制。稍后我们还会看到，SCTP 还有其他一些UDP和TCP都没有提供的新颖的特点。 3.Socket通信原理图解 A:Socket套接字概述： 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 B:Socket原理机制： 通信的两端都有Socket。 网络通信其实就是Socket间的通信。 数据在两个Socket间通过IO传输。]]></content>
      <categories>
        <category>网络</category>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.3升级mariadb至10.2]]></title>
    <url>%2F2018%2F02%2F14%2Flinux-2018-02-14-CentOS7-3%E5%8D%87%E7%BA%A7mariadb%E8%87%B310-2%2F</url>
    <content type="text"><![CDATA[安装gogs因为数据库版本太低只好升级数据库了，从github上得知MariaDB似乎10.2以上就可以解决问题了，只好升级了由于CentOS7 自带数据库 版本太低了，只能升级数据库了😭要升级原来centOS7默认带的数据库5.5，先要添加respos地址，在下面目录下新建MariaDB.repo文件 12345[root@sweet yum.repos.d]# pwd/etc/yum.repos.d[root@sweet yum.repos.d]# lsCentOS-Base.repo epel.repo MariaDB.repo[root@sweet yum.repos.d]# 在文件里写入下面的信息 12345678[root@sweet yum.repos.d]# cat MariaDB.repo\#MariaDB 10.2 CentOS repository list - created 2017-12-01 11:36 UTC\# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = https://mirrors.ustc.edu.cn/mariadb/yum/10.2/centos7-amd64gpgkey=https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1 然后就可以安装软件了，成功之后登录名和旧数据库相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102[root@sweet yum.repos.d]# sudo yum install MariaDB-server MariaDB-clientLoaded plugins: fastestmirrorbase | 3.6 kB 00:00:00epel | 4.7 kB 00:00:00extras | 3.4 kB 00:00:00mariadb | 2.9 kB 00:00:00updates | 3.4 kB 00:00:00(1/8): base/7/x86_64/group_gz | 156 kB 00:00:00(2/8): epel/x86_64/updateinfo | 880 kB 00:00:00(3/8): epel/x86_64/group_gz | 266 kB 00:00:00(4/8): extras/7/x86_64/primary_db | 166 kB 00:00:00(5/8): base/7/x86_64/primary_db | 5.7 MB 00:00:00(6/8): epel/x86_64/primary_db | 6.2 MB 00:00:00(7/8): updates/7/x86_64/primary_db | 6.0 MB 00:00:00(8/8): mariadb/primary_db | 22 kB 00:00:00Determining fastest mirrorsResolving Dependencies--&gt; Running transaction check---&gt; Package MariaDB-client.x86_64 0:10.2.13-1.el7.centos will be installed--&gt; Processing Dependency: MariaDB-common for package: MariaDB-client-10.2.13-1.el7.centos.x86_64---&gt; Package MariaDB-server.x86_64 0:10.2.13-1.el7.centos will be installed--&gt; Processing Dependency: galera for package: MariaDB-server-10.2.13-1.el7.centos.x86_64--&gt; Processing Dependency: lsof for package: MariaDB-server-10.2.13-1.el7.centos.x86_64--&gt; Running transaction check---&gt; Package MariaDB-common.x86_64 0:10.2.13-1.el7.centos will be installed--&gt; Processing Dependency: MariaDB-compat for package: MariaDB-common-10.2.13-1.el7.centos.x86_64---&gt; Package galera.x86_64 0:25.3.23-1.rhel7.el7.centos will be installed--&gt; Processing Dependency: libboost_program_options.so.1.53.0()(64bit) for package: galera-25.3.23-1.rhel7.el7.centos.x86_64---&gt; Package lsof.x86_64 0:4.87-4.el7 will be installed--&gt; Running transaction check---&gt; Package MariaDB-compat.x86_64 0:10.2.13-1.el7.centos will be installed---&gt; Package boost-program-options.x86_64 0:1.53.0-27.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved========================================================================================================== Package Arch Version Repository Size==========================================================================================================Installing: MariaDB-client x86_64 10.2.13-1.el7.centos mariadb 48 M MariaDB-server x86_64 10.2.13-1.el7.centos mariadb 110 MInstalling for dependencies: MariaDB-common x86_64 10.2.13-1.el7.centos mariadb 155 k MariaDB-compat x86_64 10.2.13-1.el7.centos mariadb 2.8 M boost-program-options x86_64 1.53.0-27.el7 base 156 k galera x86_64 25.3.23-1.rhel7.el7.centos mariadb 8.0 M lsof x86_64 4.87-4.el7 base 331 kTransaction Summary==========================================================================================================Install 2 Packages (+5 Dependent packages)Total download size: 169 MInstalled size: 719 MIs this ok [y/d/N]: yDownloading packages:warning: /var/cache/yum/x86_64/7/mariadb/packages/MariaDB-10.2.13-centos73-x86_64-common.rpm: Header V4 DSA/SHA1 Signature, key ID 1bb943db: NOKEYPublic key for MariaDB-10.2.13-centos73-x86_64-common.rpm is not installed(1/7): MariaDB-10.2.13-centos73-x86_64-common.rpm | 155 kB 00:00:00(2/7): MariaDB-10.2.13-centos73-x86_64-compat.rpm | 2.8 MB 00:00:00(3/7): boost-program-options-1.53.0-27.el7.x86_64.rpm | 156 kB 00:00:00(4/7): MariaDB-10.2.13-centos73-x86_64-client.rpm | 48 MB 00:00:08(5/7): lsof-4.87-4.el7.x86_64.rpm | 331 kB 00:00:00(6/7): MariaDB-10.2.13-centos73-x86_64-server.rpm | 110 MB 00:00:09(7/7): galera-25.3.23-1.rhel7.el7.centos.x86_64.rpm | 8.0 MB 00:00:03----------------------------------------------------------------------------------------------------------Total 14 MB/s | 169 MB 00:00:12Retrieving key from https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBImporting GPG key 0x1BB943DB: Userid : &quot;MariaDB Package Signing Key &lt;package-signing-key@mariadb.org&gt;&quot; Fingerprint: 1993 69e5 404b d5fc 7d2f e43b cbcb 082a 1bb9 43db From : https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBIs this ok [y/N]: yRunning transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : MariaDB-common-10.2.13-1.el7.centos.x86_64 1/7 Installing : MariaDB-compat-10.2.13-1.el7.centos.x86_64 2/7 Installing : MariaDB-client-10.2.13-1.el7.centos.x86_64 3/7 Installing : boost-program-options-1.53.0-27.el7.x86_64 4/7 Installing : galera-25.3.23-1.rhel7.el7.centos.x86_64 5/7 Installing : lsof-4.87-4.el7.x86_64 6/7 Installing : MariaDB-server-10.2.13-1.el7.centos.x86_64 7/7 Verifying : MariaDB-client-10.2.13-1.el7.centos.x86_64 1/7 Verifying : MariaDB-compat-10.2.13-1.el7.centos.x86_64 2/7 Verifying : lsof-4.87-4.el7.x86_64 3/7 Verifying : galera-25.3.23-1.rhel7.el7.centos.x86_64 4/7 Verifying : MariaDB-common-10.2.13-1.el7.centos.x86_64 5/7 Verifying : boost-program-options-1.53.0-27.el7.x86_64 6/7 Verifying : MariaDB-server-10.2.13-1.el7.centos.x86_64 7/7Installed: MariaDB-client.x86_64 0:10.2.13-1.el7.centos MariaDB-server.x86_64 0:10.2.13-1.el7.centosDependency Installed: MariaDB-common.x86_64 0:10.2.13-1.el7.centos MariaDB-compat.x86_64 0:10.2.13-1.el7.centos boost-program-options.x86_64 0:1.53.0-27.el7 galera.x86_64 0:25.3.23-1.rhel7.el7.centos lsof.x86_64 0:4.87-4.el7Complete!]]></content>
      <categories>
        <category>服务器</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Maria DB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 gogs安装及二级域名nginx代理]]></title>
    <url>%2F2018%2F02%2F12%2Flinux-2018-02-12-git%E6%9C%8D%E5%8A%A1%E5%99%A8gogs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[搭建gogs服务一、基础环境配置 (git和数据库)1、 git和数据库的安装由于机器(CentOS7)上没有Git 所以先要安装git 1yum install -y git 数据库安装就不演示了，本博客已经有了 2、在系统上新建账号在系统上添加一个git的系统账号，用来启动gogs软件，这样比较好 12root@sweet:~$ useradd gitroot@sweet:~$ passwd git 切换到git用户，生成 ssh 1git@sweet:~$ ssh-keygen -t rsa 二、安装gogs1、gogs下载安装下载对应的二进制文件 https://gogs.io/docs/installation/install_from_binary 1234567891011[root@sweet ~]# wget https://dl.gogs.io/0.11.34/linux_amd64.tar.gz--2018-02-17 11:31:09-- https://dl.gogs.io/0.11.34/linux_amd64.tar.gzResolving dl.gogs.io (dl.gogs.io)... 138.68.27.161Connecting to dl.gogs.io (dl.gogs.io)|138.68.27.161|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 18688444 (18M) [application/x-gzip]Saving to: ‘linux_amd64.tar.gz.1’100%[======================================&gt;] 18,688,444 4.33MB/s in 4.1s2018-02-17 11:31:15 (4.33 MB/s) - ‘linux_amd64.tar.gz.1’ saved [18688444/18688444] 解压文件 123[root@sweet ~]# lslinux_amd64.tar.gz[root@sweet ~]# tar zxvf linux_amd64.tar.gz 将文件移动到 etc 目录下，并且将所有权授权给git用户 12[root@sweet ~]# mv gogs/ /etc/[root@sweet etc]# chown git -R gogs/ 2、数据库配置接下来就是准备数据库配置了 1、创建数据库gogs2、创建数据库gogs用户3、将gogs数据库授权给gogs用户 （1）创建数据库 12mysql -u root -p &lt; scripts/mysql.sqlEnter password: 上面执行的sql其实为： 12DROP DATABASE IF EXISTS gogs;CREATE DATABASE IF NOT EXISTS gogs CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; （2）创建数据库用户并授权 123456$ mysql -u root -pEnter password:mysql&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;your_password&apos;;mysql&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;;mysql&gt; flush privileges;mysql&gt; exit （3）然后我们就可以尝试启动了，在gog文件夹下 1[root@sweet gogs]# ./gogs web 启动如下图 但是填好后提交出现错误，搜索之后的需要升级数据库，这块内容在另外一个博客里最后，我们数据库搞定之后就可以看到如下界面了登录页面如果你在第一次初始化的时候没有设置管理员，直接注册一个，第一个用户默认为管理员。 剩下的就不多说了，用法和github 类似。 Nginx 二级域名反向代理是不是每次输入一个域名后面跟着一个3000 很烦呀，没关系我们有解决的办法，那就是使用nginx代理，下面就是方法 用的是阿里的域名，添加二级域名如下图在nginx目录下配置,添加如下文件 12[root@sweet ~]# cd /etc/nginx/conf.d/[root@sweet conf.d]# vim gogs.conf gogs.conf 内配置的内容为： 12345678910server &#123; server_name git.sweetm.top; listen 80; #ssl on; location /&#123; proxy_pass http://127.0.0.1:3000/; proxy_redirect default; &#125;&#125; 然后就是我们大功告成了！]]></content>
      <categories>
        <category>服务器</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOs7安装MariaDB5.5]]></title>
    <url>%2F2018%2F02%2F11%2Flinux-2018-02-11-CentOs7%E5%AE%89%E8%A3%85MariaDB5-5%2F</url>
    <content type="text"><![CDATA[安装基于 CentOS 7 的默认版本数据库 Maria DB[1]安装 MariaDB 5.512345678[root@www ~]# yum -y install mariadb-server[root@www ~]# vi /etc/my.cnf将编码改为UTF-8 防止中文乱码[mysqld]character-set-server=utf8[root@www ~]# systemctl start mariadb [root@www ~]# systemctl enable mariadb ln -s &apos;/usr/lib/systemd/system/mariadb.service&apos; &apos;/etc/systemd/system/multi-user.target.wants/mariadb.service&apos; [2]设置 Maria DB 第一次需要初始化数据库密码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100[root@www ~]# mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we&apos;ll need the currentpassword for the root user. If you&apos;ve just installed MariaDB, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none):OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.\# set root passwordSet root password? [Y/n] yNew password:Re-enter new password:Password updated successfully!Reloading privilege tables.. ... Success!By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.\# remove anonymous usersRemove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;. Thisensures that someone cannot guess at the root password from the network.\# disallow root login remotelyDisallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named &apos;test&apos; that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.\# remove test databaseRemove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.\# reload privilege tablesReload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you&apos;ve completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB!\# connect to MariaDB with root[root@www ~]# mysql -u root -p Enter password: # MariaDB root password you setWelcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 3Server version: 5.5.37-MariaDB MariaDB ServerCopyright (c) 2000, 2014, Oracle, Monty Program Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.\# show user listMariaDB [(none)]&gt; select user,host,password from mysql.user; +------+-----------+-------------------------------------------+| user | host | password |+------+-----------+-------------------------------------------+| root | localhost | *xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx || root | 127.0.0.1 | *xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx || root | ::1 | *xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx |+------+-----------+-------------------------------------------+3 rows in set (0.00 sec)\# show database listMariaDB [(none)]&gt; show databases; +--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec)MariaDB [(none)]&gt; exitBye 安装完成]]></content>
      <categories>
        <category>服务器</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>CentOS7</tag>
        <tag>Maria DB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集计算机书籍]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%94%B6%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[ReactiveX/RxJava文档中文版 https://mcxiaoke.gitbooks.io/rxdocs/content/Docker — 从入门到实践 https://www.gitbook.com/book/yeasy/docker_practice/details]]></content>
      <categories>
        <category>计算机</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图投影和坐标系概念]]></title>
    <url>%2F2018%2F02%2F10%2F%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[面对地图坐标之间的关系，一脸懵 ，收集整合资料 基本概念地理坐标系：为球面坐标。 参考平面地是椭球面，坐标单位：经纬度；投影坐标系：为平面坐标。参考平面地是水平面，坐标单位：米、千米等；地理坐标转换到投影坐标的过程可理解为投影。（投影：将不规则的地球曲面转换为平面） 1、投影坐标系地图投影的种类很多，一般按照两种标准进行分类：一是按投影的变形性质分类，二是按照投影的构成方式分类。 1.1 按投影变形性质分类按照投影的变形性质可以分为以下几类：等角投影、等积投影、任意投影。 1.1.1 等角投影能保持无限小图形的相似。同一点上长度比处处相同-变形圆，不同点变形圆的半径不同，大范围看，投影图形与地面实际形状并不完全相似。由于这种投影无角度变形，便于图上量测方向/角度，所以常用于对真实角度和方向要求高的地图，比如航海、洋流和风向图等。由于此类投影面积变形很大，故不能量算面积。 1.1.2 等面积投影等积投影是等面积投影，便于面积的比较和量算。常用于对面积精度要求较高的自然和经济地图，如地质、土壤、土地利用、行政区划等地图。 1.1.3 任意投影任意投影既不等角又不等积，各方面变形都存在，但都适中。在任意投影中，有一类比较特殊的投影叫做等距投影，满足正轴投影中经线长度比为1，在斜轴或横轴投影中垂直圈长度比为1。任意投影常用于教学地图、科学参考地图和通用世界地图等。 1.2 按投影构成方式分类根据投影构成方式可以分为两类：几何投影和解析投影。 1.2.1几何投影几何投影是把椭球体面上的经纬网直接或附加某种条件投影到几何承影面上，然后将几何面展开为平面而得到的一类投影，包括方位投影、圆锥投影和圆柱投影。根据投影面与球面的位置关系的不同又可将其划分为：正轴投影、横轴投影、斜轴投影。如下图所示： a 方位投影：以平面作为几何承影面，使平面与椭球体面相切或相割，将球面经纬网投影到平面上而成的投影。在切点或割线上无任何变形，离切点或割线越远，变形越大。 b 圆锥投影：以圆锥作为几何承影面，使圆锥与椭球体面相切或相割，将球面经纬网投影到圆锥面上而成的投影。该投影适用于中纬度地带沿纬线方向伸展地区的地图，我国的地图多用此投影。 c 圆柱投影：以圆柱作为几何承影面，使圆柱与椭球体面相切或相割，将球面经纬网投影到圆柱面上而成的投影。该投影方式一般适用于编制赤道附近地区的地图和世界地图。 1.2.2 解析投影解析投影是不借助于辅助几何面，直接用解析法得到经纬网的一种投影。主要包括：伪方位投影，伪圆锥投影，伪圆柱投影，多圆锥投影。此处不再赘述。 a 伪方位投影：据方位投影修改而来。在正轴情况下，纬线仍为同心圆，除中央经线为直线外，其余经线均改为中央经线的曲线，且相交于纬线的圆心。 b 伪圆柱投影：据圆柱投影修改而来。在正轴圆柱投影的基础上，要求纬线仍为平行直线，除中央经线为直线外，其余的经线均改为对称于中央经线的曲线。c 伪圆锥投影：据圆锥投影修改而来。在正轴圆锥投影的基础上，要求经线仍为同心圆弧，除中央经线为直线外，其余的经线均改为对称于中央经线的曲线。d 多圆锥投影：这是一种假想借助多个圆锥表面与球体相切而设计成的投影。纬线为同轴圆弧，其圆心均位于中央经线上，中央经线为直线，其余的经线均为对称于中央经线的曲线。 1.3常见的投影1． 墨卡托(Mercator)投影%E6%8A%95%E5%BD%B1%20.jpg) 墨卡托(Mercator)投影，是一种”等角正切圆柱投影”，荷兰地图学家墨卡托（Gerhardus Mercator 1512－1594）在1569年拟定，假设地球被围在一中空的圆柱里，其标准纬线与圆柱相切接触，然后再假想地球中心有一盏灯，把球面上的图形投影到圆柱体上，再把圆柱体展开，这就是一幅选定标准纬线上的“墨卡托投影”绘制出的地图。墨卡托投影没有角度变形，由每一点向各方向的长度比相等，它的经纬线都是平行直线，且相交成直角，经线间隔相等，纬线间隔从标准纬线向两极逐渐增大。墨卡托投影的地图上长度和面积变形明显，但标准纬线无变形，从标准纬线向两极变形逐渐增大，但因为它具有各个方向均等扩大的特性，保持了方向和相互位置关系的正确。在地图上保持方向和角度的正确是墨卡托投影的优点，墨卡托投影地图常用作航海图和航空图，如果循着墨卡托投影图上两点间的直线航行，方向不变可以一直到达目的地，因此它对船舰在航行中定位、确定航向都具有有利条件，给航海者带来很大方便。“海底地形图编绘规范”（GB/T 17834-1999，海军航保部起草）中规定1：25万及更小比例尺的海图采用墨卡托投影，其中基本比例尺海底地形图（1：5万，1：25万，1：100万）采用统一基准纬线30°，非基本比例尺图以制图区域中纬为基准纬线。基准纬线取至整度或整分。 墨卡托投影坐标系取零子午线或自定义原点经线(L0)与赤道交点的投影为原点，零子午线或自定义原点经线的投影为纵坐标X轴，赤道的投影为横坐标Y轴，构成墨卡托平面直角坐标系。 2． 高斯-克吕格(Gauss-Kruger)投影和UTM（Universal Transverse Mercator）投影######（1）高斯-克吕格投影性质 高斯-克吕格(Gauss-Kruger)投影简称“高斯投影”，又名”等角横切椭圆柱投影”，地球椭球面和平面间正形投影的一种。德国数学家、物理学家、天文学家高斯（Carl FriedrichＧauss，1777一 1855）于十九世纪二十年代拟定，后经德国大地测量学家克吕格（Johannes Kruger，1857～1928）于 1912年对投影公式加以补充，故名。该投影按照投影带中央子午线投影为直线且长度不变和赤道投影为直线的条件，确定函数的形式，从而得到高斯一克吕格投影公式。投影后，除中央子午线和赤道为直线外， 其他子午线均为对称于中央子午线的曲线。设想用一个椭圆柱横切于椭球面上投影带的中央子午线，按上述投影条件，将中央子午线两侧一定经差范围内的椭球面正形投影于椭圆柱面。将椭圆柱面沿过南北极的母线剪开展平，即为高斯投影平面。取中央子午线与赤道交点的投影为原点，中央子午线的投影为纵坐标x轴，赤道的投影为横坐标y轴，构成高斯克吕格平面直角坐标系。高斯-克吕格投影在长度和面积上变形很小，中央经线无变形，自中央经线向投影带边缘，变形逐渐增加，变形最大之处在投影带内赤道的两端。由于其投影精度高，变形小，而且计算简便（各投影带坐标一致，只要算出一个带的数据，其他各带都能应用），因此在大比例尺地形图中应用，可以满足军事上各种需要，能在图上进行精确的量测计算。 ######（2）高斯-克吕格投影分带 按一定经差将地球椭球面划分成若干投影带,这是高斯投影中限制长度变形的最有效方法。分带时既要控制长度变形使其不大于测图误差，又要使带数不致过多以减少换带计算工作，据此原则将地球椭球面沿子午线划分成经差相等的瓜瓣形地带,以便分带投影。通常按经差6度或3度分为六度带或三度带。六度带自0度子午线起每隔经差6度自西向东分带，带号依次编为第 1、2…60带。三度带是在六度带的基础上分成的，它的中央子午线与六度带的中央子午线和分带子午线重合，即自 1.5度子午线起每隔经差3度自西向东分带，带号依次编为三度带第 1、2…120带。我国的经度范围西起 73°东至135°，可分成六度带十一个，各带中央经线依次为75°、81°、87°、……、117°、123°、129°、135°，或三度带二十二个。六度带可用于中小比例尺（如 1：250000）测图，三度带可用于大比例尺（如 1：10000）测图，城建坐标多采用三度带的高斯投影。 （3）高斯-克吕格投影坐标高斯- 克吕格投影是按分带方法各自进行投影，故各带坐标成独立系统。以中央经线投影为纵轴(x), 赤道投影为横轴(y),两轴交点即为各带的坐标原点。纵坐标以赤道为零起算，赤道以北为正，以南为负。我国位于北半球，纵坐标均为正值。横坐标如以中央经线为零起算，中央经线以东为正，以西为负，横坐标出现负值，使用不便，故规定将坐标纵轴西移500公里当作起始轴，凡是带内的横坐标值均加 500公里。由于高斯-克吕格投影每一个投影带的坐标都是对本带坐标原点的相对值，所以各带的坐标完全相同，为了区别某一坐标系统属于哪一带，在横轴坐标前加上带号，如(4231898m,21655933m)，其中21即为带号。 （4）高斯-克吕格投影与UTM投影某些国外的软件如ARC/INFO或国外仪器的配套软件如多波束的数据处理软件等，往往不支持高斯-克吕格投影，但支持UTM投影，因此常有把UTM投影坐标当作高斯-克吕格投影坐标提交的现象。 UTM投影全称为“通用横轴墨卡托投影”，是等角横轴割圆柱投影（高斯-克吕格为等角横轴切圆柱投影），圆柱割地球于南纬80度、北纬84度两条等高圈，该投影将地球划分为60个投影带，每带经差为6度，已被许多国家作为地形图的数学基础。UTM投影与高斯投影的主要区别在南北格网线的比例系数上，高斯-克吕格投影的中央经线投影后保持长度不变，即比例系数为1，而UTM投影的比例系数为0.9996。UTM投影沿每一条南北格网线比例系数为常数，在东西方向则为变数，中心格网线的比例系数为0.9996，在南北纵行最宽部分的边缘上距离中心点大约 363公里，比例系数为 1.00158。 高斯-克吕格投影与UTM投影可近似采用 Xutm=0.9996 X高斯，Yutm=0.9996 Y高斯进行坐标转换。以下举例说明(基准面为WGS84)： 输入坐标（度） 高斯投影（米） UTM投影（米） Xutm=0.9996 X高斯, Yutm=0.9996 Y高斯 纬度值（X）32 3543600.9 3542183.5 3543600.9*0.9996 ≈ 3542183.5 经度值（Y）121 21310996.8 311072.4 (310996.8-500000)*0.9996+500000 ≈ 311072.4 注：坐标点（32,121）位于高斯投影的21带，高斯投影Y值21310996.8中前两位“21”为带号；坐标点（32,121）位于UTM投影的51带，上表中UTM投影的Y值没加带号。因坐标纵轴西移了500000米，转换时必须将Y值减去500000乘上比例因子后再加500000。 2、地理坐标系2.1 地球的三级逼近2.1.1大地水准面地球的自然表面有高山也有洼地，是崎岖不平的，我们要使用数学法则来描述他，就必须找到一个相对规则的数学面。 大地水准面是地球表面的第一级逼近。假设当海水处于完全静止的平衡状态时，从海平面延伸到所有大陆下部，而与地球重力方向处处正交的一个连续、闭合的曲面，这就是大地水准面。 2.1.2地球椭球体大地水准面可以近似成一个规则成椭球体，但并不是完全规则，其形状接近一个扁率极小的椭圆绕短轴旋转所形成的规则椭球体，这个椭球体称为地球椭球体。它是地球的第二级逼近。 下面列举了一些常见椭球体的参数。我国1952年以前采用海福特椭球体，从1953年起采用克拉索夫斯基椭球体。 1978年我国决定采用新椭球体GRS（1975），并以此建立了我国新的、独立的大地坐标系，对应ArcGIS里面的Xian_1980椭球体。从1980年开始采用新椭球体GRS（1980），这个椭球体参数与ArcGIS中的CGCS2000椭球体相同。 2.1.3大地基准面确定了一个规则的椭球表面以后，我们会发现还有一个问题，参考椭球体是对地球的抽象，因此其并不能去地球表面完全重合，在设置参考椭球体的时候必然会出现有的地方贴近的好（参考椭球体与地球表面位置接近），有地地方贴近的不好的问题，因此这里还需要一个大地基准面来控制参考椭球和地球的相对位置。 这是地球表面的第三级逼近。有以下两类基准面： 地心基准面：由卫星数据得到，使用地球的质心作为原点，使用最广泛的是 WGS 1984。 区域基准面：特定区域内与地球表面吻合，大地原点是参考椭球与大地水准面相切的点，例如Beijing54、Xian80。我们通常称谓的Beijing54、Xian80坐标系实际上指的是我国的两个大地基准面。 我们通常说的参心大地坐标系和地心大地坐标系的区别就在于此。参心大地坐标系：指经过定位与定向后，地球椭球的中心不与地球质心重合而是接近地球质心。区域性大地坐标系。是我国基本测图和常规大地测量的基础。如Beijing54、Xian80。地心大地坐标系：指经过定位与定向后，地球椭球的中心与地球质心重合。如CGCS2000、WGS84。 2.2 地理坐标地理坐标，就是用经线（子午线）、纬线、经度、纬度表示地面点位的球面坐标。 一般地理坐标可分为三种，天文经纬度，大地经纬度，地心经纬度。通常地图上使用的经纬度都为大地经纬度，所以这里我介绍一下大地经纬度，其他两种要想了解的话可以百度一下，其实区别不大。 大地经纬度：大地经度：参考椭球面上某点的大地子午面与本初子午面间的两面角。东正西负。 大地纬度 ：参考椭球面上某点的法线与赤道平面的夹角。北正南负。 大地高： 指某点沿法线方向到参考椭球面的距离。 看到这里，地理坐标系的思路基本明确的了吧！只需要参考椭球体参数以及大地基准面就可以确定地理坐标系。下面是Arcgis中对北京1954坐标系的说明。主要就是以下几个参数：123Prime Meridian（起始经度）Datum（大地基准面）: D_Beijing_1954Spheroid（参考椭球体）: Krasovsky_1940 （克拉索夫斯基椭球体） 常见的问题1）说“经纬度投影”对吗？ 经纬度表示的是地理坐标系（单位是度），不是投影坐标系（单位是米），两者放一起明显不妥。 2）大地坐标系与地理坐标系有何不同？ 大地坐标系和地理坐标系都是经纬度表示的坐标系，本身并不包含投影信息，很多时候，这两种说法都是相同的。 3）为什么有地理坐标系和投影坐标系之分？ 由于经纬度的度数不对应某一标准长度，因此无法精确测量距离或面积，也难以在平面地图或计算机屏幕上显示数据。在使用许多（不是全部）GIS 分析和制图应用程序时，经常需要由投影坐标系提供的更稳定的平面坐标框架。与地理坐标系不同，在二维空间范围内，投影坐标系的长度、角度和面积恒定。投影坐标系始终基于地理坐标系，而后者则是基于球体或旋转椭球体的。在投影坐标系中，通过格网上的 x,y 坐标来标识位置，其原点位于格网中心。 4）通常所说的西安80，北京54是指什么？ GIS中的坐标系统定义由基准面和地图投影两组参数确定，基准面对应一个参考椭球体，我们常说的北京54、西安80、国家大地2000坐标系都是指其参考椭球体。基于这种椭球体，我们能定义出大地坐标系和投影坐标系。只说一个西安80是不能确定坐标系统的，因为没有说明有没有投影及投影信息。如果不指明投影方式，则认为西安80、北京54的表现形式为大地坐标，而不是投影平面直角坐标。 5）什么都是高斯投影 ？ 高斯-克吕格投影属于横轴墨卡托投影，能小范围内保持形状不变，因此被国内普遍采用，但在表示小比例尺数据时，这种投影明显不合适。就中国来说，一般50万以上比例尺采用高斯投影，50万以下采用兰伯特投影。数据用途不同，具体的投影方式各有不同，有的是为了保持面积不变，有的是为了保持形状不变。另一种世界常用的投影是UTM（通用墨卡托投影），高斯-克吕格投影是“等角横切椭圆柱投影”，投影后中央经线保持长度不变，即比例系数为1；UTM投影是“等角横轴割圆柱投影”，圆柱割地球于南纬80度、北纬84度两条等高圈，投影后两条割线上没有变形，中央经线上长度比 0.9996。 6）北京54，西安80，WGS84，国家2000 有何不同？ 54和80本质上是参心坐标系，大地原点分别在苏联和西安，原点是参考椭球的几何中心，这类坐标难以表达高度信息，精度信息等也不够，正被淘汰。。 84和2000本质上是地心坐标系，即以地球质量中心作为坐标系原点。 54的椭球体长半轴半径是6378245米，80为6378140米，84和2000坐标系一样，都是6378137米。国家最新的2000坐标系和WGS84据说在厘米级都是一样的，但和80坐标在高纬度地区误差达十几倍。 7) Google、Microsoft、ArcGIS提供的地图服务分别采用了什么坐标系？ 现在都统一为了Web Mercator，即正轴墨卡托投影，和UTM（常规墨卡托）投影的主要区别是为了实现上的方便，把地球模拟为球体而非椭球体，精度理论上差别0.33%，比例尺大时基本可以忽略。同时纬度范围变成了(-85,85),南北极显示不了，但不影响正常使用，这样也减少了切图数量。 8）ArcGIS的空间参考与坐标系统？ ArcGIS的空间参考信息SpatialReference，不仅包含了坐标系统的定义，还包括容差Tolerance和分辨率Resolution等，通常由Prj文件表示。ArcGIS中的坐标系统分地理坐标系和投影坐标系，其中投影坐标系也一定包含一个地理坐标系，反之不然。]]></content>
      <categories>
        <category>无人机</category>
        <category>地图</category>
      </categories>
      <tags>
        <tag>地图</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机是如何实现自动对焦]]></title>
    <url>%2F2018%2F02%2F09%2F%E6%89%8B%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6%2F</url>
    <content type="text"><![CDATA[一、话不多说，我们首先来看看相机聚焦的原理是什么？然后再让它自动这个图我们都熟悉，中学时候的凸透镜成像的原理 要保证xx’=ff‘，这样才能得到清晰的像，可以发现物距x跟像距x’具有共轭关系，当物距x变化时，要么调节焦距f，要门调节像距x’，才能在相机上得到我们清晰的像 二、接着我们来了解下什么是景深？通俗来讲就是相机（底片）上，成清晰像的范围其实对于最简单的照相机（一块凸透镜）来说，唯一的一个物距仅对应一个像距，所以景深为0，偏离一点点都会不清晰。但是为什么我们的照相机拍出来的不光是一个面上是清晰的呢？因为我们的照相机跟人眼一样，它的景深可以做到趋近无限远（注意趋近）∞。两者的应用情况不同，对于工业定位而言，精度要达到微米级别，所以景深要做到尽可能小；对于我们民用的照相机而言，重点是景色，全景，拍一个面肯定就不行了啊下面三图是智能手机拍的照片：第一幅是在一定距离，我点击屏幕，让它对焦“杭州”，接着向上平移，没有再点击屏幕使其对焦，发现杭州俩字变模糊了，这时候的情况是焦距、像距均无变化，仅物距变化，显然就会造成模糊（但是不至于很模糊，还记的我们之前说的趋近于无限远的景深吗？如果无限远了，就一样清晰了，但是实际情况做不到，只能趋近），那我怎样让成像清晰呢？1、改变物距，所以图3我把一支笔上移了一段举例，可以看到笔身的字体还是蛮清晰的2、点击屏幕，重新聚焦，这时候改变的就是焦距跟像距了 三、那相机怎样像人一样判断，是否聚焦了呢？这里就用到了图像清晰度评价算法，常用的有这么几种： 频域分析法和统计学函数由于对抗噪声能力弱，算法复杂，应用较少，现有应用主要是上面的灰度梯度类算法及其改进算法具体的学术算法就不讲了，巴拉巴拉…得出结论是有那么几种算法，时间、准确性上都非常好 四、但是峰值位置怎么来求呢？一种是遍历法，就是每一点的图片清晰度值都计算出来，最后找到最大值，但这种算法未免太过浪费时间，效率低下，还有一种算法是爬山算法，基本原理是，先粗调，再精调，最终高效的找到图像清晰度最大的点（峰值）。找到后驱动电机运转一定角度，实现像距或者焦距的变化，步进到最佳成像位置五、差不多就是这么多，所以相机自动聚焦时，都会有个从模糊到清晰，到模糊，再到清晰的过程，这就是相机的自动调焦了 对之前的知识进行一定补充：介绍两个不同的概念 对焦：对我们的手机来说，对焦仅仅是实现物距跟像距的变化，达到共轭关系，使得成像清晰，而这是通过手机里面的音圈马达实现的，驱动整个镜头组移动来实现。限于手机体积的原因，只能达到这样的水平。 变焦：但是手机摄像头其实是多个棱镜片组成的，比如iPhone6 是由6片塑料棱镜组成的镜头模组，限于手机体积，我们没办法改变棱镜片之间的距离，所以我们改变不了手机的焦距。这也就是我们的手机只能做到数码变焦（其实就是把你拍的照片单纯放大而已，越大，成像会越不清晰），而光学变焦，目前来看，还没有谁成功在手机上运用 原贴地址：知乎]]></content>
      <categories>
        <category>无人机</category>
        <category>拍照</category>
      </categories>
      <tags>
        <tag>相机</tag>
        <tag>飞控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[景深概念及计算]]></title>
    <url>%2F2018%2F02%2F04%2F%E7%B2%BE%E6%B7%B1%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[先介绍几个概念：1、焦点(focus)与光轴平行的光线射入凸透镜时，理想的镜头应该是所有的光线聚集在一点后，再以锥状的扩散开来，这个聚集所有光线的一点，就叫做焦点。 2、弥散圆(circle of confusion)在焦点前后，光线开始聚集和扩散，点的影象变成模糊的，形成一个扩大的圆，这个圆就叫做弥散圆。 在现实当中，观赏拍摄的影象是以某种方式(比如投影、放大成照片等等)来观察的，人的肉眼所感受到的影象与放大倍率、投影距离及观看距离有很大的关系，如果弥散圆的直径小于人眼的鉴别能力，在一定范围内实际影象产生的模糊是不能辨认的。这个不能辨认的弥散圆就称为容许弥散圆(permissible circle of confusion)。 不同的厂家、不同的胶片面积都有不同的容许弥散圆直径的数值定义。一般常用的是： 画幅 24mm x 36mm 6cm x 9cm 4” x 5” 弥散圆直径 0.035mm 0.0817mm 0.146mm 35mm照相镜头的容许弥散圆，大约是底片对角线长度的1/1000~1/1500左右。前提是画面放大为5x7英寸的照片，观察距离为25~30cm。 3、景深(depth of field)在焦点前后各有一个容许弥散圆，这两个弥散圆之间的距离就叫景深，即：在被摄主体(对焦点)前后，其影像仍然有一段清晰范围的，就是景深。换言之，被摄体的前后纵深，呈现在底片面的影象模糊度，都在容许弥散圆的限定范围内。 景深随镜头的焦距、光圈值、拍摄距离而变化。对于固定焦距和拍摄距离，使用光圈越小，景深越大。 以持照相机拍摄者为基准，从焦点到近处容许弥散圆的的距离叫前景深，从焦点到远方容许弥散圆的距离叫后景深。 4、景深的计算下面是景深的计算公式。其中： δ — 容许弥散圆直径 f — 镜头焦距 F — 镜头的拍摄光圈值 L — 对焦距离 ΔL1 — 前景深 ΔL2 — 后景深 ΔL — 景深 $$前景深 ΔL1=\frac{FδL^2}{f^2 + FδL} 公式(1)$$$$后景深 ΔL2=\frac{FδL^2}{f^2 - FδL} 公式(2)$$$$景深 ΔL=ΔL1+ΔL2=\frac{2f^2FδL^2}{f^4 - F^2δ^2L^2}$$ 从公式(1)和(2)可以看出，后景深 &gt; 前景深。 由景深计算公式可以看出，景深与镜头使用光圈、镜头焦距、拍摄距离以及对像质的要求(表现为对容许弥散圆的大小)有关。这些主要因素对景深的影响如下(假定其他的条件都不改变)：(1)、镜头光圈：光圈越大，景深越小；光圈越小，景深越大；(2)、镜头焦距镜头焦距越长，景深越小；焦距越短，景深越大；(3)、拍摄距离距离越远，景深越大；距离越近，景深越小。 5、一些计算实例网上有些在线计算器，有兴趣的网友可以参考：摄影光学计算器Windows版本的可下载的计数器在f/Calc(1)、200/2.8对焦在5m时，f/2.8的景深： δ=0.035mmf=200mmF=2.8L=5000mmΔL1=60mmΔL2=62mmΔL=122mm结论： 该镜头在用f/2.8拍摄时，清晰范围是从4.94m~5.062m，景深很浅。 (2)、200/2.8+2X=400/5.6对焦在5m时，f/5.6的景深： δ=0.035mmf= 400mmF= 5.6L= 5000mmΔL1= 30mmΔL2= 31mmΔL= 61mm结论： 该镜头在配合2X增距镜后，主镜头用f/2.8拍摄时，景深是(1)的一半。 景深的实际拍摄照片 注：本内容是从其他博客得来，但是找不到原贴了]]></content>
      <categories>
        <category>无人机</category>
        <category>拍照</category>
      </categories>
      <tags>
        <tag>相机</tag>
        <tag>飞控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初相遇]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%B8%AD%E6%85%95%E8%93%89-%E5%88%9D%E7%9B%B8%E9%81%87%2F</url>
    <content type="text"><![CDATA[初相遇 美丽的梦和美丽的诗一样都是可遇而不可求的常常在最没能料到的时刻里出现 我喜欢那样的梦在梦里 一切都可以重新开始一切都可以慢慢解释心里甚至还能感觉到所有被浪费的时光竟然都能重回时的狂喜和感激 胸怀中满溢著幸福只因为你就在我眼前对我微笑 一如当年我真喜欢那样的梦 明明知道你已为我跋涉千里却又觉得芳草鲜美 落英缤纷好像你我才初初相遇]]></content>
      <categories>
        <category>书</category>
        <category>诗集</category>
      </categories>
      <tags>
        <tag>席慕蓉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL基础复习]]></title>
    <url>%2F2017%2F09%2F23%2Fandroid-2017-09-23-AIDL%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[AIDL1、创建AIDL:实体对象、新建AIDL文件、make工程 2、服务端：新建Binder对象、定义方法123456789// 包名需要和原始类的一样parcelable Person;interface IMyAidl &#123; void addPerson(in Person person); List&lt;Person&gt; getPersonList();&#125; 3、客户端：实现serviceConnection、BindService12345678910111213141516171819202122232425262728293031public class MyAidlService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); private ArrayList&lt;Person&gt; mPersons; /** * 创建生成的本地 Binder 对象，实现 AIDL 制定的方法 */ private IBinder mIBinder = new IMyAidl.Stub() &#123; @Override public void addPerson(Person person) throws RemoteException &#123; mPersons.add(person); &#125; @Override public List&lt;Person&gt; getPersonList() throws RemoteException &#123; return mPersons; &#125; &#125;; /** * 客户端与服务端绑定时的回调，返回 mIBinder 后客户端就可以通过它远程调用服务端的方法，即实现了通讯 * * @param intent * @return */ @Nullable @Override public IBinder onBind(Intent intent) &#123; mPersons = new ArrayList&lt;&gt;(); Log.d(TAG, "MyAidlService onBind"); return mIBinder; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyServiceActivity extends Activity &#123; private Button mBtn; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBtn = findViewById(R.id.btn); mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent1 = new Intent(getApplicationContext(), MyAidlService.class); bindService(intent1, mConnection, BIND_AUTO_CREATE); addPerson(); &#125; &#125;); &#125; private IMyAidl mAidl; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //连接后拿到 Binder，转换成 AIDL，在不同进程会返回个代理 //获取到远端的Binder 进行操作 mAidl = IMyAidl.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mAidl = null; &#125; &#125;; List&lt;Person&gt; personList; public void addPerson() &#123; Random random = new Random(); Person person = new Person("shixin" + random.nextInt(10)); try &#123; mAidl.addPerson(person); personList = mAidl.getPersonList(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Aidl生成类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public interface IMyAidl extends IInterface &#123; void addPerson(Person var1) throws RemoteException; List&lt;Person&gt; getPersonList() throws RemoteException; public abstract static class Stub extends Binder implements IMyAidl &#123; private static final String DESCRIPTOR = "com.example.jiajiemu.test.IMyAidl"; static final int TRANSACTION_addPerson = 1; static final int TRANSACTION_getPersonList = 2; public Stub() &#123; this.attachInterface(this, "com.example.jiajiemu.test.IMyAidl"); &#125; public static IMyAidl asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; else &#123; IInterface iin = obj.queryLocalInterface("com.example.jiajiemu.test.IMyAidl"); return (IMyAidl)(iin != null &amp;&amp; iin instanceof IMyAidl ? (IMyAidl)iin : new IMyAidl.Stub.Proxy(obj)); &#125; &#125; public IBinder asBinder() &#123; return this; &#125; public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch(code) &#123; case 1: data.enforceInterface("com.example.jiajiemu.test.IMyAidl"); Person _arg0; if (0 != data.readInt()) &#123; _arg0 = (Person)Person.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addPerson(_arg0); reply.writeNoException(); return true; case 2: data.enforceInterface("com.example.jiajiemu.test.IMyAidl"); List&lt;Person&gt; _result = this.getPersonList(); reply.writeNoException(); reply.writeTypedList(_result); return true; case 1598968902: reply.writeString("com.example.jiajiemu.test.IMyAidl"); return true; default: return super.onTransact(code, data, reply, flags); &#125; &#125; private static class Proxy implements IMyAidl &#123; private IBinder mRemote; Proxy(IBinder remote) &#123; this.mRemote = remote; &#125; public IBinder asBinder() &#123; return this.mRemote; &#125; public String getInterfaceDescriptor() &#123; return "com.example.jiajiemu.test.IMyAidl"; &#125; public void addPerson(Person person) throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); try &#123; _data.writeInterfaceToken("com.example.jiajiemu.test.IMyAidl"); if (person != null) &#123; _data.writeInt(1); person.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; this.mRemote.transact(1, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; public List&lt;Person&gt; getPersonList() throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); ArrayList _result; try &#123; _data.writeInterfaceToken("com.example.jiajiemu.test.IMyAidl"); this.mRemote.transact(2, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(Person.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service基础复习]]></title>
    <url>%2F2017%2F09%2F23%2Fandroid-2017-09-23-Service%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Service1、service和线程(Thread)的区别和场景(1) Thread:程序执行的最小单元，它是分配CPU的基本单位 生命周期1.新建2.就绪3.运行4.死亡5.阻塞 (2) Service是Android的一种机制，服务是运行在主线程上的使用的是进程间的通信机制 生命周期1.onCreate2.onStart3.onDestory4.onBind5.onUnbind 2、如何管理service生命周期生命周期图 上图使用两种方发启动服务 (1)多次StartService,onCreate只会调用一次，而onStartCommand()多次。 (2)StopService调用如果已经被onBind的Service,需要unBindService方法之后才可以stop (3)bindService 绑定服务 (3)调用unBindService()方法，内部会走onUnbind()方法 3、service和IntentService的区别？1、IntentService时继承并处理异步请求的一个类2、内部有一个工作线程来处理耗时的任务3、IntentService 内部则是通过消息的方式发送给HandlerThread的，然后有Handler中的Looper来处理消息 4、启动服务和绑定服务先后次序问题android 系统只会给Service创建一个对象，不管是以哪种方式创建1、先绑定服务后启动服务 绑定服务会转换为服务状态，需要调用stopService() 2、先启动服务后绑定服务 绑定服务后，及时activity销毁后，调用unBindService()之后，调用stopService才能销毁服务 总结：启动服务的优先级比绑定服务高，服务是托管在主线程中运行的 5、序列化：Parcelable和Serializable序列化：内存中-&gt;磁盘 java 中提供的方法，对内存的消耗大12345678910111213141516171819202122232425public class SerializableImplement implements Serializable &#123; /** * 生成序列号标识 反序列化判断serialVersionUID 是否一致来 反序列化 */ private static final long serialVersionUID = -2083503801443301445L; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; android 提供的方法，内存消耗小1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ParcableImplement implements Parcelable &#123; public int id; public String name; /** * 当前对象的内容描述,一般返回0即可 * * @return */ @Override public int describeContents() &#123; return 0; &#125; //读写数据，写的顺序和读的顺序必须一致 protected ParcableImplement(Parcel in) &#123; this.id = in.readInt(); this.name = in.readString(); &#125; /** * 将当前对象写入序列化结构中 * * @param dest * @param flags */ @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.id); dest.writeString(this.name); &#125; /** * public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。 * 重写接口中的两个方法： * createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层， * newArray(int size) 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。 */ public static final Creator&lt;ParcableImplement&gt; CREATOR = new Creator&lt;ParcableImplement&gt;() &#123; /** * 从序列化后的对象中创建原始对象 */ @Override public ParcableImplement createFromParcel(Parcel in) &#123; return new ParcableImplement(in); &#125; /** * 创建指定长度的原始对象数组 * @param size * @return */ @Override public ParcableImplement[] newArray(int size) &#123; return new ParcableImplement[size]; &#125; &#125;;&#125; 总结：如果内存之间序列话，优先 反序列化:磁盘-&gt;内存中]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask基础复习]]></title>
    <url>%2F2017%2F09%2F23%2Fandroid-2017-09-23-AsyncTask-%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[AsyncTask1、使用注意事项 AsyncTask的实例必须在主线程中创建 AsyncTask的execute方法必须在主线程中调用 回调方法，Android会自动调用 一个AsyncTask的实例，只能执行一次execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class UpdateTextTask extends AsyncTask&lt;Void, Integer, Integer&gt; &#123; private Context context; UpdateTextTask(Context context) &#123; this.context = context; &#125; /** * 运行在UI线程中，在调用doInBackground()之前执行 */ @Override protected void onPreExecute() &#123; Toast.makeText(context, "开始执行", Toast.LENGTH_SHORT).show(); &#125; /** * 后台运行的方法，可以运行非UI线程，可以执行耗时的方法 */ @Override protected Integer doInBackground(Void... voids) &#123; int i = 0; while (i &lt; 10) &#123; i++; publishProgress(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; &#125; return null; &#125; /** * 运行在ui线程中，在doInBackground()执行完毕后执行 */ @Override protected void onPostExecute(Integer integer) &#123; Toast.makeText(context, "执行完毕", Toast.LENGTH_SHORT).show(); &#125; /** * 在publishProgress()被调用以后执行，publishProgress()用于更新进度 */ @Override protected void onProgressUpdate(Integer... values) &#123;// tv.setText(""+values[0]); &#125;//使用 new UpdateTextTask(MainActivity.this).execute();]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toast 在有的机型上不能显示通知的问题]]></title>
    <url>%2F2017%2F09%2F23%2Fandroid-2017-08-01-Toast%E5%9C%A8%E6%9C%89%E7%9A%84%E6%9C%BA%E5%9E%8B%E4%B8%8A%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%80%9A%E7%9F%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Toast 在有的机型上不能显示通知 我开发的软件是无人机自动化APP,在DJI平板上运行的时候发现Toast显示不能正常的显示出来，所以只能翻源码查看原因了 12345678910111213141516171819/** * Show the view for the specified duration. */public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 通过上面的的代码会发现，Toast通知是需要有INotificationManager 这个的权限，说以就百度找方法啦，判断有没有通知权限，提醒用户在平板上打开通知权限。 检查是否有通知权限1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NotificationsUtils &#123; private static final String CHECK_OP_NO_THROW = "checkOpNoThrow"; private static final String OP_POST_NOTIFICATION = "OP_POST_NOTIFICATION"; @SuppressLint("NewApi") public static boolean isNotificationEnabled(Context context) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; return isEnableV26(context); &#125; else &#123; AppOpsManager mAppOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; Class appOpsClass = null; /* Context.APP_OPS_MANAGER */ try &#123; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(CHECK_OP_NO_THROW, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(OP_POST_NOTIFICATION); int value = (Integer) opPostNotificationValue.get(Integer.class); return ((Integer) checkOpNoThrowMethod.invoke(mAppOps, value, uid, pkg) == AppOpsManager.MODE_ALLOWED); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; &#125; /** * 8.0以上获取t通知栏状态 * * @param context * @return */ private static boolean isEnableV26(Context context) &#123; ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; try &#123; NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); Method sServiceField = notificationManager.getClass().getDeclaredMethod("getService"); sServiceField.setAccessible(true); Object sService = sServiceField.invoke(notificationManager); Method method = sService.getClass().getDeclaredMethod("areNotificationsEnabledForPackage" , String.class, Integer.TYPE); method.setAccessible(true); return (boolean) method.invoke(sService, pkg, uid); &#125; catch (Exception e) &#123; return true; &#125; &#125; 如果没有通知权限，使用下面代码跳转到设置界面12345678910111213141516171819202122232425262728293031323334353637383940414243private void chekcNotifiction() &#123; if (!NotificationsUtils.isNotificationEnabled(this)) &#123; final AlertDialog dialog = new AlertDialog.Builder(this).create(); dialog.show(); View view = View.inflate(this, R.layout.dialog, null); dialog.setContentView(view); TextView context = (TextView) view.findViewById(R.id.tv_dialog_context); context.setText("检测到您没有打开通知权限，是否去打开"); TextView confirm = (TextView) view.findViewById(R.id.btn_confirm); confirm.setText("确定"); confirm.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; dialog.cancel(); Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) &#123; localIntent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); localIntent.setData(Uri.fromParts("package", MainActivity.this.getPackageName(), null)); &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123; localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName("com.android.settings", "com.android.settings.InstalledAppDetails"); localIntent.putExtra("com.android.settings.ApplicationPkgName", MainActivity.this.getPackageName()); &#125; startActivity(localIntent); &#125; &#125;); TextView cancel = (TextView) view.findViewById(R.id.btn_off); cancel.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; dialog.cancel(); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>遇到的坑</category>
      </categories>
      <tags>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler基础复习]]></title>
    <url>%2F2017%2F09%2F23%2Fandroid-2017-09-23-Handler%2F</url>
    <content type="text"><![CDATA[Handler这个分析的思路是 创建Handler-&gt;发送消息-&gt;接受消息 为主线来分析源码的 1、创建Handler 的方法在这个方法里面，获取了当前线程的Looper，获取了Looper的消息队列 123456789101112131415161718192021 public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125;//获取当前线程的Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; //消息队列 mQueue = mLooper.mQueue; //消息callback mCallback = callback; mAsynchronous = async; &#125; 创建Handler之前需要当前线程创建了Looper源码里面的例子，简单的举例了Handler的机制12345678910111213141516class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; //Looper的初始化 Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; //轮询消息 Looper.loop(); &#125;&#125; prepare() 方法源码 Looper里面的源码从这段代码可以看出Looper时绑定每个线程的，且每个线程只有一个轮询器，把我们的消息都推送大一个队列里面 12345678910// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();//sThreadLocal 每个线程独占的存储空间，不相互影响private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; sThreadLocal 每个线程独占的存储空间，不相互影响,或获取线程里面的Map 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 2、发送消息 sendMessage123456789101112131415161718192021222324252627282930313233public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; // 重点， 将当前的Handler 添加到Message里面 msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 3、MessageQueue 插入消息这就是我们消息队列插入消息的源码，我们 sendMessage的消息都是通过这个方法进入队列的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 4、Looper 对象 管理Message1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 轮训方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; //这里通过msg 的target 绑定的对象将消息分发出去 msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, "Dispatch took " + time + "ms on " + Thread.currentThread().getName() + ", h=" + msg.target + " cb=" + msg.callback + " msg=" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 源码分析]]></title>
    <url>%2F2016%2F09%2F06%2Fjava-%E5%AE%B9%E5%99%A8-05-HashMap%2F</url>
    <content type="text"><![CDATA[HashMap 源码分析先介绍一下 HashMap使用的数据结构 基于 Java 1.8 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 1、成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * The default initial capacity - MUST be a power of two. */ //默认的初始化容量大小 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ //最大的存储容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ //默认的加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ //当哈希冲突深度超过8改用，红黑树 static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ //存储HashMap key的数组 transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ //可以看到HashMap里面使用Set来存储Key transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; 1、DEFAULT_INITIAL_CAPACITY 作用 An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.HashMap的一个实例有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中的桶数，初始容量只是创建哈希表时的容量。加载因子是在自动增加容量之前允许哈希表获取的完整程度的度量。当哈希表中的条目数超过加载因子和当前容量的乘积时，哈希表将被重新哈希（即，重建内部数据结构），以便哈希表具有大约两倍的桶数。 2、DEFAULT_LOAD_FACTOR 作用 As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. 作为一般规则，默认加载因子（.75）在时间和空间成本之间提供了良好的折衷。较高的值会减少空间开销，但会增加查找成本（反映在HashMap类的大多数操作中，包括get和put）。在设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以便最小化重新散列操作的数量。如果初始容量大于最大条目数除以加载因子，则不会发生重新加载操作。 2、数据结构HashMap使用的数据结构是这样的，由一个数组加链接的结构体构成。Node[] table 和 Node 构成了HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 2、构造函数12345678910111213141516171819202122232425public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 3、插入数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果 table 数组为null的话，初始化数组，调用 resize() n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)//判断计算出的位置有没有对象 /** (n - 1) &amp; hash 为计算 数据在数组中的索引位置 **/ tab[i] = newNode(hash, key, value, null); else &#123;//如果已经有对象，通过链表连接到已经有的对象下个节点 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//已经存在节点，替换值 e = p; else if (p instanceof TreeNode)// 二叉树节点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//key的hash值相等，但是并不是同一个对象 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //用来转换为树节点 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //计算HashMap的修改次数 ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; (n - 1) &amp; hash 是计算key的hash在数组中的位置 4、 获取数据12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 5、hash 函数1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 6、resize函数这个函数的作用是 初始化数组和扩充数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 总结我们现在可以回答开始的几个问题，加深对HashMap的理解： 1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。]]></content>
      <categories>
        <category>Java</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet源码分析]]></title>
    <url>%2F2016%2F09%2F03%2Fjava-%E5%AE%B9%E5%99%A8-04-HashSet%E5%92%8CLinkedHashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、HashSet源码分析 123public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable 特点元素是无序的，保持唯一性 源码1.构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;/** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; /** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ //可以看出这个构造函数是留给 LinkedHashSet留下来的 HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 2.成员变量123456//可以看到 HashSet底层使用的其实就是HashMapprivate transient HashMap&lt;E,Object&gt; map;// 这个对象用来，当HashSet的值// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); 3.函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Returns an iterator over the elements in this set. The elements * are returned in no particular order. * * @return an Iterator over the elements in this set * @see ConcurrentModificationException */public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125;/** * Returns the number of elements in this set (its cardinality). * * @return the number of elements in this set (its cardinality) */public int size() &#123; return map.size();&#125;/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements */public boolean isEmpty() &#123; return map.isEmpty();&#125;/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set * contains an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this set is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element */public boolean contains(Object o) &#123; return map.containsKey(o);&#125;/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;/** * Removes all of the elements from this set. * The set will be empty after this call returns. */public void clear() &#123; map.clear();&#125;/** * Returns a shallow copy of this &lt;tt&gt;HashSet&lt;/tt&gt; instance: the elements * themselves are not cloned. * * @return a shallow copy of this set */@SuppressWarnings(&quot;unchecked&quot;)public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(e); &#125;&#125; 二、LinkedHashSet 1、构造函数由 继承关系可以看出 LinkedHashSet 是 HashSet的子类，可以看出HashSet留私有的构造函数，是留给LinkedHashSet留下的1234567891011121314151617public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125;public LinkedHashSet() &#123; super(16, .75f, true);&#125;public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkList源码分析]]></title>
    <url>%2F2016%2F09%2F01%2Fjava-%E5%AE%B9%E5%99%A8-03-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LinkList源码分析 特点LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高 添加了的功能 添加，删除，获取开头或者结尾 开始分析源码1、先看继承关系123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 2、先看成员变量123456789101112131415161718// 记录集合的长度transient int size = 0;// 链表头节点/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;// 链表尾节点/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last; 3、构造函数并没有干什么12345/** * Constructs an empty list. */public LinkedList() &#123;&#125; 4、介绍里面的链表关联结构体 双向链表 1234567891011121314private static class Node&lt;E&gt; &#123; //当前的节点 E item; //下一个节点 Node&lt;E&gt; next; //上一个节点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 5、增123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public boolean add(E e) &#123; linkLast(e); return true;&#125;public void addFirst(E e) &#123; linkFirst(e);&#125;public void addLast(E e) &#123; linkLast(e);&#125;public void push(E e) &#123; addFirst(e);&#125;/** * Links e as first element. */private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) //如果当前的头节点为null 则 尾节点也为插入的节点 last = newNode; else f.prev = newNode; size++; modCount++;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;//批量添加public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查索引是在范围内 checkPositionIndex(index); //将进来的Collection 都转换为数组 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 6、删1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;public E pop() &#123; return removeFirst();&#125;/** * Unlinks non-null first node f. */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125;/** * Unlinks non-null last node l. */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125;/** * Unlinks non-null node x. */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 7、改1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 8、clear 所有的数据1234567891011121314151617public void clear() &#123; // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator //这个循环比较有意思µ for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2016%2F08%2F30%2Fjava-%E5%AE%B9%E5%99%A8-02-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList源码分析一、ArrayList的特点1.ArrayList是动态数组实现的List，其容量能自动增长2.ArrayList是非线程安全的，线程安全的考虑Collections.synchronizedList(list)或concurrent并发包下的CopyOnWriteArrayList类3.ArrayList实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，所以适用于快速访问和修改 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 4.ArrayList每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低, 所以不适用随机插入和删除5.ArrayList允许元素为null6.ArrayList默认容量大小为10，扩容为当前容量的1.5倍，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList 源码分析1、ArrayList的全局变量12345678910111213141516171819202122232425262728293031323334353637 /** * Default initial capacity. */ //默认的 容量的大小 private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ // 当数据不符合的时候使用的空数组 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ //new ArrayList() 对象时使用的数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ //ArrayList 存放数据的数组 transient Object[] elementData; // non-private to simplify nested class access/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ // 数组存储最大的容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 2、构造函数123456789101112131415public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 数组扩展123456789101112131415161718/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //数组每次扩容按照 每次增加现在容量的0.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash和HashCode的介绍]]></title>
    <url>%2F2016%2F08%2F29%2Fjava-Hash%E5%92%8ChashCode%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.Hash的作用介绍 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x到首字母 F(x)的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 基本概念1.若关键字为 k，则其值存放在$f(k)$的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。2.对不同的关键字可能得到同一散列地址，即 $k_1 \neq k_2$，而 $f(k_1)=f(k_2)$，这种现象称为 哈希冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 $ f(k)$和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。3.若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。 2、HashCode的作用 HashCode是Object的一个方法，hashCode方法返回一个hash code值，且这个方法是为了更好的支持hash表，比如String，Set，HashTable、HashMap等; 2.1. HashCode的特性（1）HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址；（2）如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同；（3）两个对象的HashCode相同，并不一定表示两个对象就相同，即equals()不一定为true，只能够说明这两个对象在一个散列存储结构中。（4）如果对象的equals方法被重写，那么对象的HashCode也尽量重写。 正确的equals0方法必须满足下列5个条件:1)自反性。对任意x, x.equals(x)一定返回true。2)对称性。对任意x和y,如果y.equals(x)返 回true,则x.equals(y)也返 回true。3)传递性。对任意x、y、z,如果有x.equals(y)返 回ture, y.equals(z)返 回true,则x.equals(z) 一定返回true。4)一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持-致，要么- -直是true,要么-直是false。5)对任何不是null的x, x.equals(nu)- 定返 回false。 3. Java 中HashCode的作用 从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。 3.1 String对象12345678910111213141516171819202122232425262728293031323334public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125;public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 3.2 Integer对象1234567891011public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125;@Overridepublic int hashCode() &#123; return Integer.hashCode(value);&#125; 4、在HashMap中put的逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 从上面代码中，在HashMap的put方法调用的过程中，使用 key的hash 值进行重复性的检测 部分资料来自：http://www.importnew.com/18851.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>HashCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器概览图]]></title>
    <url>%2F2016%2F08%2F29%2Fjava-%E5%AE%B9%E5%99%A8-01-%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[容器的类关系图 容器部分知识点集合]]></content>
      <categories>
        <category>Java</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表概念]]></title>
    <url>%2F2016%2F08%2F01%2Fjava-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表 &emsp;&emsp;哈希表是一种数据结构，它可以提供快速的插入操作和查找操作。第一次接触哈希表时，它的优点多得让人难以置信。不论哈希表中有多少数据，插入和删除(有时包括刪除)只需要接近常量的时间:即0(1)的时间级。实际上，这只需要几条机器指令。&emsp;&emsp;对哈希表的使用者一.人来说，这是一瞬间的事。哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录，通常使用哈希表(例如拼写检查器)。哈希表的速度明显比树快，正如前面几章看到的，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。&emsp;&emsp;哈希表也有一些缺点:它是基于数组的，数组创建后难于扩展。某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据(或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程)。而且，也没有-种简便的方法可以以任何一种顺序(例如从小到大)遍历表中数据项。如果需要这种能力，就只能选择其他数据结构。然而，如果不需要有序遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度和易用性方面是无与伦比的。 1git config --global user.name "Sweetm" 1git config --global user.email mkyxlx@163.com]]></content>
      <categories>
        <category>Java</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的排序算法]]></title>
    <url>%2F2016%2F06%2F25%2F%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 排序算法大体可分为两种： 一种是比较排序，时间复杂度最少可达到O(n log n)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。 另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 这里我们来探讨一下常用的比较排序算法，非比较排序算法将在后续文章中介绍。下表给出了常见比较排序算法的性能： 这里有一点我们很容易忽略的是排序算法的稳定性(腾讯校招2016笔试题曾考过)。 排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。 对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。 例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。 其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。 冒泡排序（Bubble Sort） 冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，一次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;int main()&#123; int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大冒泡排序 int n = sizeof(A) / sizeof(int); for (int j = 0; j &lt; n - 1; j++) // 每次最大元素就像气泡一样"浮"到数组的最后 &#123; for (int i = 0; i &lt; n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移 &#123; if (A[i] &gt; A[i + 1]) // 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法 &#123; exchange(A, i, i + 1); &#125; &#125; &#125; printf("冒泡排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下 冒泡排序的改进：鸡尾酒排序 鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。 鸡尾酒排序的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;int main()&#123; int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大定向冒泡排序 int n = sizeof(A) / sizeof(int); int left = 0; // 初始化边界 int right = n - 1; while (left &lt; right) &#123; for (int i = left; i &lt; right; i++) // 前半轮,将最大元素放到后面 if (A[i] &gt; A[i + 1]) &#123; exchange(A, i, i + 1); &#125; right--; for (int i = right; i &gt; left; i--) // 后半轮,将最小元素放到前面 if (A[i - 1] &gt; A[i]) &#123; exchange(A, i - 1, i); &#125; left++; &#125; printf("鸡尾酒排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125; 使用鸡尾酒排序为一列数字进行排序的过程如下图所示： 以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。 选择排序(Selection Sort) 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- O(n^2)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;int main()&#123; int A[] = &#123; 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 &#125;; // 从小到大选择排序 int n = sizeof(A) / sizeof(int); int i, j, min; for (i = 0; i &lt;= n - 2; i++) // 已排序序列的末尾 &#123; min = i; for (j = i + 1; j &lt;= n - 1; j++) // 未排序序列 &#123; if (A[j] &lt; A[min])// 依次找出未排序序列中的最小值,存放到已排序序列的末尾 &#123; min = j; &#125; &#125; if (min != i) &#123; exchange(A, min, i); // 该操作很有可能把稳定性打乱,所以选择排序是不稳定的排序算法 &#125; &#125; printf("选择排序结果："); for (i = 0; i &lt; n; i++) &#123; printf("%d ",A[i]); &#125; printf("\n"); return 0;&#125; 上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如上图 使用选择排序为一列数字进行排序的宏观过程： 选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。 比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。 插入排序(Insertion Sort) 插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌 对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序取出下一个元素，在已经排序的元素序列中从后向前扫描如果该元素（已排序）大于新元素，将该元素移到下一位置重复步骤3，直到找到已排序的元素小于或者等于新元素的位置将新元素插入到该位置后重复步骤2~5 插入排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;// 分类 ------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定int main()&#123; int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;// 从小到大插入排序 int n = sizeof(A) / sizeof(int); int i, j, get; for (i = 1; i &lt; n; i++) // 类似抓扑克牌排序 &#123; get = A[i]; // 右手抓到一张扑克牌 j = i - 1; // 拿在左手上的牌总是排序好的 while (j &gt;= 0 &amp;&amp; A[j] &gt; get) // 将抓到的牌与手牌从右向左进行比较 &#123; A[j + 1] = A[j]; // 如果该手牌比抓到的牌大,就将其右移 j--; &#125; A[j + 1] = get;// 直到该手牌比抓到的牌小(或二者相等),将抓到的牌插入到该手牌右边(相等元素的相对次序未变,所以插入排序是稳定的) &#125; printf("插入排序结果："); for (i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下 使用插入排序为一列数字进行排序的宏观过程： 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 插入排序的改进：二分插入排序 对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目，我们称为二分插入排序，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大二分插入排序 int n = sizeof(A) / sizeof(int); int i, j, get, left, right, middle; for (i = 1; i &lt; n; i++) // 类似抓扑克牌排序 &#123; get = A[i]; // 右手抓到一张扑克牌 left = 0; // 拿在左手上的牌总是排序好的,所以可以用二分法 right = i - 1; // 手牌左右边界进行初始化 while (left &lt;= right) // 采用二分法定位新牌的位置 &#123; middle = (left + right) / 2; if (A[middle] &gt; get) right = middle - 1; else left = middle + 1; &#125; for (j = i - 1; j &gt;= left; j--) // 将欲插入新牌位置右边的牌整体向右移动一个单位 &#123; A[j + 1] = A[j]; &#125; A[left] = get; // 将抓到的牌插入手牌 &#125; printf("二分插入排序结果："); for (i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125; 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。 插入排序的更高效改进：希尔排序(Shell Sort) 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 希尔排序的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; // 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)// 最优时间复杂度 ---- O(n)// 平均时间复杂度 ---- 根据步长序列的不同而不同。// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大希尔排序 int n = sizeof(A) / sizeof(int); int i, j, get; int h = 0; while (h &lt;= n) // 生成初始增量 &#123; h = 3*h + 1; &#125; while (h &gt;= 1) &#123; for (i = h; i &lt; n; i++) &#123; j = i - h; get = A[i]; while ((j &gt;= 0) &amp;&amp; (A[j] &gt; get)) &#123; A[j + h] = A[j]; j = j - h; &#125; A[j + h] = get; &#125; h = (h - 1) / 3; // 递减增量 &#125; printf("希尔排序结果："); for (i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125; 以23, 10, 4, 1的步长序列进行希尔排序： 希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。 比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。 归并排序(Merge Sort) 归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。 归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。 归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作,归并操作步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列设定两个指针，最初位置分别为两个已经排序序列的起始位置比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针到达序列尾将另一序列剩下的所有元素直接复制到合并序列尾 归并排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;limits.h&gt; // 包含极限值的头文件，这里用到了无穷大INT_MAX// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(n)// 稳定性 ------------ 稳定int L[10]; // 两个子数组定义成全局变量（辅助存储空间,大小正比于元素的个数）int R[10];void merge(int A[], int left, int middle, int right)// 合并两个已排好序的数组A[left...middle]和A[middle+1...right]&#123; int n1 = middle - left + 1; // 两个数组的大小 int n2 = right - middle; for (int i = 0; i &lt; n1; i++) // 把两部分分别拷贝到两个数组中 L[i] = A[left + i]; for (int j = 0; j &lt; n2; j++) R[j] = A[middle + j + 1]; L[n1] = INT_MAX; // 使用无穷大作为哨兵值放在子数组的末尾 R[n2] = INT_MAX; // 这样可以免去检查某个子数组是否已读完的步骤 int i = 0; int j = 0; for (int k = left; k &lt;= right; k++) // 依次比较两个子数组中的值，每次取出更小的那一个放入原数组 &#123; if (L[i] &lt;= R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125;&#125;void mergesort_recursion(int A[], int left, int right) // 递归实现的归并排序(自顶向下)&#123; int middle = (left + right) / 2; if (left &lt; right) // 当待排序的序列长度为1时(left == right)，递归“开始回升” &#123; mergesort_recursion(A, left, middle); mergesort_recursion(A, middle + 1, right); merge(A, left, middle, right); &#125;&#125;void mergesort_iteration(int A[], int left, int right) // 非递归(迭代)实现的归并排序(自底向上)&#123; int low, middle, high; // 子数组索引,前一个为A[low...middle],后一个子数组为A[middle+1...high] for (int size = 1; size &lt;= right - left; size *= 2) // 子数组的大小初始为1,每轮翻倍 &#123; low = left; while (low + size - 1 &lt;= right - 1 )// 后一个子数组存在(需要归并) &#123; middle = low + size - 1; high = middle + size; if (high &gt; right) // 后一个子数组大小不足size high = right; merge(A, low, middle, high); low = high + 1; // 前一个子数组索引向后移动 &#125; &#125;&#125;int main()&#123; int A1[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大归并排序 int A2[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; int n1 = sizeof(A1) / sizeof(int); int n2 = sizeof(A2) / sizeof(int); mergesort_recursion(A1, 0, n1 - 1); // 递归实现 mergesort_iteration(A2, 0, n2 - 1); // 非递归实现 printf("递归实现的归并排序结果："); for (int i = 0; i &lt; n1; i++) &#123; printf("%d ",A1[i]); &#125; printf("\n"); printf("非递归实现的归并排序结果："); for (int i = 0; i &lt; n2; i++) &#123; printf("%d ", A2[i]); &#125; printf("\n"); return 0;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下 使用归并排序为一列数字进行排序的宏观过程： 堆排序(Heapsort) 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构（通常堆是通过一维数组来实现的），并同时满足堆的性质：即子结点的键值总是小于（或者大于）它的父节点。 我们可以很容易的定义堆排序的过程：1.创建一个堆2.把堆顶元素(最大值)和堆尾元素互换3.把堆的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整4.重复步骤2，直到堆的尺寸为1 堆排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定int heapsize; // 堆大小void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;void heapify(int A[], int i) // 堆调整函数(这里使用的是最大堆)&#123; int leftchild = 2 * i + 1; // 左孩子索引 int rightchild = 2 * i + 2; // 右孩子索引 int largest; // 选出当前结点与左右孩子之中的最大值 if (leftchild &lt; heapsize &amp;&amp; A[leftchild] &gt; A[i]) largest = leftchild; else largest = i; if (rightchild &lt; heapsize &amp;&amp; A[rightchild] &gt; A[largest]) largest = rightchild; if (largest != i) &#123; exchange(A, i, largest); // 把当前结点和它的最大(直接)子节点进行交换 heapify(A, largest); // 递归调用，继续从当前结点向下进行堆调整 &#125;&#125;void buildheap(int A[], int n) // 建堆函数&#123; heapsize = n; for (int i = heapsize / 2 - 1; i &gt;= 0; i--) // 对每一个非叶结点 heapify(A, i); // 不断的堆调整&#125;void heapsort(int A[], int n)&#123; buildheap(A, n); for (int i = n - 1; i &gt;= 1; i--) &#123; exchange(A, 0, i); // 将堆顶元素(当前最大值)与堆的最后一个元素互换(该操作很有可能把后面元素的稳定性打乱,所以堆排序是不稳定的排序算法) heapsize--; // 从堆中去掉最后一个元素 heapify(A, 0); // 从新的堆顶元素开始进行堆调整 &#125;&#125;int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大堆排序 int n = sizeof(A) / sizeof(int); heapsort(A, n); printf("堆排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125; 堆排序算法的演示： 动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。 堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。 比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。 快速排序(Quicksort) 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为： 从序列中挑出一个元素，作为”基准”(pivot)，重新排序序列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准的后面（相同的数可以到任一边）。这个称为分区(partition)操作。递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。递归的最底部情形，是序列的大小是0或1，也就是永远都已经被排序好了。 快速排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;// 分类 ------------ 内部比较排序// 数据结构 --------- 数组// 最差时间复杂度 ---- O(n^2),待排序的元素有序时为最差情况,并不多见// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(logn)～O(n),主要是递归造成的栈空间的使用(用来保存left和right等局部变量),取决于递归树的深度// 一般为O(logn),最差为O(n)（基本有序的情况）// 稳定性 ---------- 不稳定void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;int partition(int A[], int left, int right) // 划分函数&#123; int pivot = A[right]; // 选择子数组最后一个元素作为基准 int tail = left - 1; // tail为小于基准的子数组最后一个元素的索引 for (int i = left; i &lt; right; i++) // 遍历基准以外的其他元素 &#123; if (A[i] &lt;= pivot) // 把小于等于基准的元素放到前一个子数组中 &#123; tail++; exchange(A, tail, i); &#125; &#125; exchange(A, tail + 1, right); // 最后把基准放到前一个子数组的后边,剩下的子数组既是大于基准的子数组 // 该操作很有可能把后面元素的稳定性打乱,所以快速排序是不稳定的排序算法 return tail + 1; // 返回基准的索引&#125;void quicksort(int A[], int left, int right)&#123; int pivot_index; // 基准的索引 if (left &lt; right) &#123; pivot_index = partition(A, left, right); quicksort(A, left, pivot_index-1); quicksort(A, pivot_index+1, right); &#125;&#125;int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大快速排序 int n = sizeof(A) / sizeof(int); quicksort(A, 0, n - 1); printf("快速排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ",A[i]); &#125; printf("\n"); return 0;&#125; 使用快速排序法对一列数字进行排序的过程： 快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。 比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML关系图]]></title>
    <url>%2F2015%2F02%2F24%2F%20UML%E5%85%B3%E7%B3%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。箭头指向】：带三角箭头的实线，箭头指向父类 实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.【箭头指向】：带三角箭头的虚线，箭头指向接口 关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体 组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体 依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖下面这张UML图，比较形象地展示了各种类图关系： UML类图几种关系的总结]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
</search>
