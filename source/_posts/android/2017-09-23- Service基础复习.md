---
title: Service基础复习
date: 2017-09-23 15:36:17
tags: 
- Service
categories: 
- Android
- 基础知识
---

## Service 

#### 1、service和线程(Thread)的区别和场景

(1) Thread:程序执行的最小单元，它是分配CPU的基本单位
* 生命周期
1.新建
2.就绪
3.运行
4.死亡
5.阻塞

(2) Service是Android的一种机制，服务是运行在主线程上的 
使用的是进程间的通信机制
* 生命周期
1.onCreate
2.onStart
3.onDestory
4.onBind
5.onUnbind

#### 2、如何管理service生命周期

生命周期图
![1548342328341](assets/1548342328341.png)

上图使用两种方发启动服务

(1)多次StartService,onCreate只会调用一次，而onStartCommand()多次。

(2)StopService调用如果已经被onBind的Service,需要unBindService方法之后才可以stop

(3)bindService 绑定服务

(3)调用unBindService()方法，内部会走onUnbind()方法

#### 3、service和IntentService的区别？
1、IntentService时继承并处理异步请求的一个类
2、内部有一个工作线程来处理耗时的任务
3、IntentService 内部则是通过消息的方式发送给HandlerThread的，然后有Handler中的Looper来处理消息

#### 4、启动服务和绑定服务先后次序问题
android 系统只会给Service创建一个对象，不管是以哪种方式创建
1、先绑定服务后启动服务 
* 绑定服务会转换为服务状态，需要调用stopService()

2、先启动服务后绑定服务
* 绑定服务后，及时activity销毁后，调用unBindService()之后，调用stopService才能销毁服务

总结：启动服务的优先级比绑定服务高，服务是托管在主线程中运行的

####  5、序列化：Parcelable和Serializable
序列化：内存中->磁盘

java 中提供的方法，对内存的消耗大
``` java
public class SerializableImplement implements Serializable {
    /**
     * 生成序列号标识   反序列化判断serialVersionUID 是否一致来 反序列化
     */
    private static final long serialVersionUID = -2083503801443301445L;

    private int id;
    private String name;
    
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```
android 提供的方法，内存消耗小
```  java 
public class ParcableImplement implements Parcelable {
    public int id;
    public String name;
    /**
     * 当前对象的内容描述,一般返回0即可
     *
     * @return
     */
    @Override
    public int describeContents() {
        return 0;
    }
    //读写数据，写的顺序和读的顺序必须一致
    protected ParcableImplement(Parcel in) {
        this.id = in.readInt();
        this.name = in.readString();
    }

    /**
     * 将当前对象写入序列化结构中
     *
     * @param dest
     * @param flags
     */
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(this.id);
        dest.writeString(this.name);
    }

    /**
     * public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。
     * 重写接口中的两个方法：
     * createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层，
     * newArray(int size) 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。
     */
    public static final Creator<ParcableImplement> CREATOR = new Creator<ParcableImplement>() {
        /**
         * 从序列化后的对象中创建原始对象
         */
        @Override
        public ParcableImplement createFromParcel(Parcel in) {
            return new ParcableImplement(in);
        }

        /**
         * 创建指定长度的原始对象数组
         * @param size
         * @return
         */
        @Override
        public ParcableImplement[] newArray(int size) {
            return new ParcableImplement[size];
        }
    };
}

```
总结：
如果内存之间序列话，优先

反序列化:磁盘->内存中